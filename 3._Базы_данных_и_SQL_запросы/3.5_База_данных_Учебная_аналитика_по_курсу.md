# 3.5 База данных "Учебная аналитика по курсу"

## Оглавление

Теория:

[Вхождение символов в строки, регулярные выражения. `REGEXP`, `INSTR`, `REGEXP_INSTR`](#Вхождение-сиволов-в-строки-регулярные-выражения-REGEXP-INSTR-REGEXP_INSTR)

Задачи:

[Создание базы данных](#Создание-базы-данных)

[Задание Step 2](#Задание-Step-2)

[Задание Step 3](#Задание-Step-3)

[Задание Step 4](#Задание-Step-4)



## Создание базы данных

### Предметная область
Курс на платформе Stepik состоит из нескольких модулей, каждый модуль включает несколько уроков, для каждого урока хранится информация о его положении в модуле. Каждый урок состоит из последовательности шагов. Каждый шаг имеет свой тип (это может быть текст, задание на SQL и пр.) и также порядковый номер в уроке.

Пользователи регистрируются на курсе, указывают свое имя. Когда пользователь проходит курс на платформе Stepik, все его действия оставляют "цифровой след": какие задания и когда он выполнил, сколько попыток сделал, правильно ли решил задание. Также хранятся все его комментарии. Если пользователь проходит курс и получает сертификат, то сохраняется дата его выдачи. Вся эта информация является первичной для учебной аналитики.

Учебная аналитика – это измерение, сбор, анализ и представление данных об обучающихся и их действиях на online платформе с целью понимания и оптимизации учебного процесса и той среды, где этот процесс происходит.

Для данного урока была создана база данных с полным описанием структуры курса. Учебная аналитика же включена в базу не в полном объеме, а только для некоторой группы пользователей из-за большого объема данных. Так, например, информация о решениях 17000 пользователей по нашему курсу за полгода его существования содержит 534500 записей. 

Пользователей для базы данных урока мы отобрали так:
* отбросили всех, кто не выполнил ни одного задания (их оказалось 8800);
* сгруппировали оставшихся пользователей в зависимости от количества решенных заданий
* затем отобрали типичных представителей групп более или менее пропорционально численности каждой группы (имена пользователей, конечно, заменили);
* поскольку пользователи отправляли от 1 до 1000 решений за время прохождения курса, в базу включили только попытки  шагов, относящихся к урокам 1.2, 2.2 и 2.4.

Получилось 64 пользователя и более 2000 их попыток.

### Логическая схема базы данных 
![pic-logi](https://ucarecdn.com/df6e64a7-45f3-4914-8d4b-1f2f272a0e40/)

### Некоторые пояснения
Иногда ключ состоит из двух столбцов. Это сделано для того, чтобы в таблицу нельзя было включить одинаковые записи. Для создания таблицы с двумя ключами используется код:
```SQL
CREATE TABLE step_keyword (
    step_id INT,
    keyword_id INT,
    PRIMARY KEY (step_id, keyword_id),
    FOREIGN KEY (step_id)  REFERENCES step (step_id) ON DELETE CASCADE,
    FOREIGN KEY (keyword_id)  REFERENCES keyword (keyword_id) ON DELETE CASCADE
);
```
#### Работа с датами
Формате  **Unix-время**, в котором хранится количество секунд, прошедших с 1 января 1970 года.

Для перевода к привычному типу `DATE` используется формула:
```
1970-01-01 + time_unix / 86400
```
В SQL для перевода удобно использовать функцию  
```SQL
FROM_UNIXTIME(time_unix)
```
[:arrow_up:Оглавление](#Оглавление)


## Задание Step 2
Отобрать все шаги, в которых рассматриваются вложенные запросы (то есть в названии шага упоминаются вложенные запросы). Указать к какому уроку и модулю они относятся. Для этого вывести 3 поля:
* в поле `Модуль` указать номер модуля и его название через пробел;
* в поле `Урок` указать номер модуля, порядковый номер урока (`lesson_position`) через точку и название урока через пробел;
* в поле `Шаг` указать номер модуля, порядковый номер урока (`lesson_position`) через точку, порядковый номер шага (`step_position`) через точку и название шага через пробел.

Длину полей Модуль и Урок ограничить 19 символами, при этом слишком длинные надписи обозначить многоточием в конце (16 символов - это номер модуля или урока, пробел и  название Урока или Модуля к ним присоединить "..."). Информацию отсортировать по возрастанию номеров модулей, порядковых номеров уроков и порядковых номеров шагов.
```SQL
SELECT 
      CONCAT(
            LEFT(CONCAT(module_id, ' ', module_name), 16), 
            '...') AS Модуль,
      CONCAT(
            LEFT(CONCAT(module_id, '.', lesson_position, ' ', lesson_name), 16), 
            '...') AS Урок,

                 CONCAT(module_id, '.', lesson_position, '.', step_position, ' ', step_name) 
                   AS Шаг
FROM       module
INNER JOIN lesson USING(module_id)
INNER JOIN step   USING(lesson_id)
WHERE step_name LIKE '%ложен%запрос%'
ORDER BY module_id, lesson_position, step_position
```
```
+---------------------+---------------------+-------------------------------------------------------------+
| Модуль              | Урок                | Шаг                                                         |
+---------------------+---------------------+-------------------------------------------------------------+
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.2 Вложенный запрос, возвращающий одно значение          |
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.3 Использование вложенного запроса в выражении          |
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.4 Вложенный запрос, оператор IN                         |
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.5 Вложенный запрос, операторы ANY и ALL                 |
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.6 Вложенный запрос после SELECT                         |
| 1 Основы реляцио... | 1.5 Запросы корр... | 1.5.5 Добавление записей, вложенные запросы                 |
| 2 Запросы SQL к ... | 2.2 Запросы на в... | 2.2.7 Запросы для нескольких таблиц со вложенными запросами |
| 2 Запросы SQL к ... | 2.2 Запросы на в... | 2.2.8 Вложенные запросы в операторах соединения             |
| 2 Запросы SQL к ... | 2.3 Запросы корр... | 2.3.5 Запрос на обновление, вложенные запросы               |
+---------------------+---------------------+-------------------------------------------------------------+
```
Вариант с учетом того, что длина названия модуля или урока в общем случае может и не превышать 19
```SQL
SET @limit = 19;
WITH steps AS
(
    SELECT
        module_id, lesson_id, lesson_position, step_id, step_position,
        CONCAT(module_id, ' ' , module_name) AS Модуль,
        CONCAT(module_id, '.', lesson_position, ' ' , lesson_name) AS Урок,
        CONCAT(module_id, '.', lesson_position, '.', step_position, ' ' , step_name) AS Шаг
    FROM
        module
        INNER JOIN lesson USING (module_id)
        INNER JOIN step   USING (lesson_id)
    WHERE LOWER(step_name) LIKE '%вложенн% запрос%'
)
SELECT
    IF(LENGTH(Модуль) <= @limit, Модуль, CONCAT(LEFT(Модуль, @limit-3), '...')) AS Модуль,
    IF(LENGTH(Урок)   <= @limit,   Урок, CONCAT(LEFT(  Урок, @limit-3), '...')) AS Урок,
    Шаг
FROM  steps
ORDER BY module_id, lesson_position, step_position;
```
[:arrow_up:Оглавление](#Оглавление)

## Вхождение символов в строки, регулярные выражения. `REGEXP`, `INSTR`, `REGEXP_INSTR`.
### `REGEXP`
`REGEXP` позволяет задать регулярное выражение, которому должно соответствовать значение столбца. В этом плане `REGEXP` представляет более изощренный и комплексный способ фильтрации, нежели оператор `LIKE`. Это [ссылка на документацию](https://dev.mysql.com/doc/refman/8.0/en/regexp.html#regexp-syntax).

`REGEXP` имеет похожий синтаксис:
```SQL
WHERE выражение [NOT] REGEXP регулярное выражение
```
Регулярное выражение может принимать следующие специальные символы:
* `^` указывает на начало строки
* `$` указывает на конец строки
* `.` соответствует любому одиночному символу
* `[символы]` соответствует любому одиночному символу из квадратных скобок
* `[начальный_символ-конечный_символ]` соответствует любому одиночному символу из диапазона символов
* `|` отделяет два шаблона строки, и значение должно соответствовать одному из этих шаблонов
* `\\b` cимвол конца слова - проверит на то, есть ли пробел, запятая, начало или конец строки и так далее.

Функция `REGEXP` возвращает булевое значение(true/false), если что-то нашла.

Примеры `REGEXP`:

`WHERE ProductName REGEXP 'Phone'`: строка должна содержать "Phone", например, `iPhone X`, `Nokia Phone N`, `iPhone`

`WHERE ProductName REGEXP '^Phone'`: строка должна начинаться с "Phone", например, `Phone 34`, `PhoneX`

`WHERE ProductName REGEXP 'Phone$'`: строка должна заканчиваться на "Phone", например, `iPhone`, `Nokia Phone`

`WHERE ProductName REGEXP 'iPhone [78]'`: строка должна содержать либо `iPhone 7`, либо `iPhone 8`

`WHERE ProductName REGEXP 'iPhone [6-8]'`: строка должна содержать либо `iPhone 6`, либо `iPhone 7`, либо `iPhone 8`

Например, найдем товары, названия которых содержат либо "Phone", либо "Galaxy":
```SQL
SELECT * FROM Products
WHERE ProductName REGEXP 'Phone|Galaxy';
``` 
### `INSTR()`
Чтобы проверить, есть ли слово в строке, можно использовать функцию:
```SQL
INSTR(string, word)
```
которая возвращает позицию первого вхождения `word` в `string`. Если вхождения нет - результат функции 0.
### `REGEXP_INSTR()`
`REGEXP_INSTR(string, word)` делает то же самое, что и `INSTR(string, word)`, только вторым аргументом можно подставить регулярное выражение.

[:arrow_up:Оглавление](#Оглавление)

## Задание Step 3
Заполнить таблицу `step_keyword` следующим образом: если ключевое слово есть в названии шага, то включить в `step_keyword` строку с id шага и id ключевого слова.

Обратите внимание, что некоторые ключевые слова, например `IN`, входят в `INNER` и `JOIN`. Нужно учитывать только отдельные слова, которые разделены в названии шага либо пробелом, либо запятой, либо открывающей скобкой.
```SQL
INSERT INTO step_keyword
SELECT step_id  , keyword_id
FROM step
CROSS JOIN keyword
WHERE REGEXP_INSTR(step_name, CONCAT('\\b', keyword_name, '\\b')) <> 0;
```
<details>
<summary>Результат</summary>
<blockquote>
Это не итоговая таблица. Она просто визуально показывает, правильно ли будет сформирована итоговая.
<tt>
+--------------------------------------------------------------+--------------+
| step_name                                                    | keyword_name |
+--------------------------------------------------------------+--------------+
| Вложенный запрос после SELECT                                | SELECT       |
| Соединение INNER JOIN                                        | INNER        |
| Внешнее соединение LEFT и RIGHT OUTER JOIN                   | LEFT         |
| Внешнее соединение LEFT и RIGHT OUTER JOIN                   | RIGHT        |
| Внешнее соединение LEFT и RIGHT OUTER JOIN                   | OUTER        |
| Соединение INNER JOIN                                        | JOIN         |
| Внешнее соединение LEFT и RIGHT OUTER JOIN                   | JOIN         |
| Перекрестное соединение CROSS JOIN                           | JOIN         |
| Перекрестное соединение CROSS JOIN                           | CROSS        |
| Выборка данных по условию, групповые функции, WHERE и HAVING | WHERE        |
| Выборка данных по условию, групповые функции, WHERE и HAVING | HAVING       |
| Выборка данных, групповые функции SUM и COUNT                | SUM          |
| Выборка данных, групповые функции MIN, MAX и AVG             | AVG          |
| Выборка данных c вычислением, групповые функции, AVG         | AVG          |
| Выборка данных, групповые функции SUM и COUNT                | COUNT        |
| Выборка данных, групповые функции MIN, MAX и AVG             | MIN          |
| Выборка данных по условию, групповые функции, MIN            | MIN          |
| Выборка данных, групповые функции MIN, MAX и AVG             | MAX          |
| Операция соединение, использование USING()                   | USING        |
| Задание. Работа с архивной таблицей, оператор UNION, часть 1 | UNION        |
| Задание. Работа с архивной таблицей, оператор UNION, часть 2 | UNION        |
| Вложенный запрос, операторы ANY и ALL                        | ALL          |
| Вложенный запрос, операторы ANY и ALL                        | ANY          |
| Выборка данных, операторы BETWEEN, IN                        | IN           |
| Вложенный запрос, оператор IN                                | IN           |
| Выборка данных, оператор LIKE                                | LIKE         |
| Выборка данных, операторы BETWEEN, IN                        | BETWEEN      |
+--------------------------------------------------------------+--------------+
</tt>
Итоговая таблица:
<tt>
Affected rows: 27
Query result: step_keyword
+---------+------------+
| step_id | keyword_id |
+---------+------------+
| 38      | 1          |
| 81      | 3          |
| 82      | 4          |
| 82      | 5          |
| 82      | 6          |
| 81      | 7          |
| 82      | 7          |
| 83      | 7          |
| 83      | 8          |
| 47      | 10         |
| 47      | 11         |
| 42      | 15         |
| 43      | 16         |
| 44      | 16         |
| 42      | 17         |
| 43      | 18         |
| 46      | 18         |
| 43      | 19         |
| 88      | 26         |
| 112     | 27         |
| 113     | 27         |
| 37      | 28         |
| 37      | 29         |
| 18      | 30         |
| 36      | 30         |
| 19      | 31         |
| 18      | 32         |
+---------+------------+
</tt>
</blockquote>
</details>

## Задание Step 4
Реализовать поиск по ключевым словам. Вывести шаги, с которыми связаны ключевые слова `MAX` и `AVG` одновременно. Для шагов указать id модуля, позицию урока в модуле, позицию шага в уроке через точку, после позиции шага перед заголовком - пробел. Позицию шага в уроке вывести в виде двух цифр (если позиция шага меньше 10, то перед цифрой поставить 0). Столбец назвать `Шаг`. Информацию отсортировать по первому столбцу в алфавитном порядке.
```SQL
SELECT CONCAT(
    module_id, '.', 
    lesson_position, '.', 
    IF(step_position < 10, CONCAT('0', step_position), step_position), ' ',
    step_name ) AS Шаг
FROM
    (
        SELECT step_id 
        FROM step_keyword AS sk
        INNER JOIN keyword AS k ON k.keyword_id = sk.keyword_id 
                               AND k.keyword_name = 'MAX'
    ) t1
CROSS JOIN
    (
        SELECT step_id 
        FROM step_keyword AS sk
        INNER JOIN keyword AS k ON k.keyword_id = sk.keyword_id 
                               AND k.keyword_name = 'AVG'
    ) t2
    ON t1.step_id = t2.step_id
INNER JOIN step ON t1.step_id = step.step_id
INNER JOIN lesson USING(lesson_id)
INNER JOIN module USING(module_id) 
ORDER BY Шаг;
```
```
+---------------------------------------------------------+
| Шаг                                                     |
+---------------------------------------------------------+
| 1.3.04 Выборка данных, групповые функции MIN, MAX и AVG |
| 1.4.06 Вложенный запрос после SELECT                    |
+---------------------------------------------------------+
```
Альтернатива:
```SQL
SELECT 
    concat(module_id,'.',lesson_position,
           IF(step_position < 10, ".0","."),
           step_position," ",step_name) AS Шаг
FROM
   step
   JOIN lesson USING(lesson_id)
   JOIN module USING(module_id)
   JOIN step_keyword USING (step_id)
   JOIN keyword USING(keyword_id)
WHERE keyword_name = 'MAX' OR keyword_name ='AVG'
GROUP BY ШАГ
HAVING COUNT(*) = 2
ORDER BY 1;
```


[:arrow_up:Оглавление](#Оглавление)


[:arrow_up:Оглавление](#Оглавление)[:arrow_up:Оглавление](#Оглавление)[:arrow_up:Оглавление](#Оглавление)[:arrow_up:Оглавление](#Оглавление)[:arrow_up:Оглавление](#Оглавление)[:arrow_up:Оглавление](#Оглавление)

