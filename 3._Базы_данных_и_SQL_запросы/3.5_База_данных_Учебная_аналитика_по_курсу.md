# 3.5 База данных "Учебная аналитика по курсу"

## Оглавление

Теория:

[Вхождение символов в строки, регулярные выражения. `REGEXP`, `INSTR`, `REGEXP_INSTR`](#Вхождение-символов-в-строки-регулярные-выражения-REGEXP-INSTR-REGEXP_INSTR)

[Выборка данных по нескольким условиям, оператор `CASE`](#Выборка-данных-по-нескольким-условиям-оператор-CASE)

[Табличные выражения, оператор `WITH`](#Табличные-выражения-оператор-WITH)

[Оконные функции, оператор `OVER`, `ORDER BY`](#Оконные-функции-оператор-OVER-ORDER-BY)

[Оконные функции, оператор `OVER`, `PARTITION BY`](Оконные-функции-оператор-OVER-PARTITION-BY)

Задачи:

[Создание базы данных](#Создание-базы-данных)

[Задание Step 2](#Задание-Step-2)

[Задание Step 3](#Задание-Step-3)

[Задание Step 4](#Задание-Step-4)

[Задание Step 5](#Задание-Step-5)

[Задание Step 6](#Задание-Step-6)

[Задание Step 7](#Задание-Step-7)

[Задание Step 8](#Задание-Step-8)

[Задание Step 9](#Задание-Step-9)

[Задание Step 10](#Задание-Step-10)


## Создание базы данных

### Предметная область
Курс на платформе Stepik состоит из нескольких модулей, каждый модуль включает несколько уроков, для каждого урока хранится информация о его положении в модуле. Каждый урок состоит из последовательности шагов. Каждый шаг имеет свой тип (это может быть текст, задание на SQL и пр.) и также порядковый номер в уроке.

Пользователи регистрируются на курсе, указывают свое имя. Когда пользователь проходит курс на платформе Stepik, все его действия оставляют "цифровой след": какие задания и когда он выполнил, сколько попыток сделал, правильно ли решил задание. Также хранятся все его комментарии. Если пользователь проходит курс и получает сертификат, то сохраняется дата его выдачи. Вся эта информация является первичной для учебной аналитики.

Учебная аналитика – это измерение, сбор, анализ и представление данных об обучающихся и их действиях на online платформе с целью понимания и оптимизации учебного процесса и той среды, где этот процесс происходит.

Для данного урока была создана база данных с полным описанием структуры курса. Учебная аналитика же включена в базу не в полном объеме, а только для некоторой группы пользователей из-за большого объема данных. Так, например, информация о решениях 17000 пользователей по нашему курсу за полгода его существования содержит 534500 записей. 

Пользователей для базы данных урока мы отобрали так:
* отбросили всех, кто не выполнил ни одного задания (их оказалось 8800);
* сгруппировали оставшихся пользователей в зависимости от количества решенных заданий
* затем отобрали типичных представителей групп более или менее пропорционально численности каждой группы (имена пользователей, конечно, заменили);
* поскольку пользователи отправляли от 1 до 1000 решений за время прохождения курса, в базу включили только попытки  шагов, относящихся к урокам 1.2, 2.2 и 2.4.

Получилось 64 пользователя и более 2000 их попыток.

### Логическая схема базы данных 
![pic-logi](https://ucarecdn.com/df6e64a7-45f3-4914-8d4b-1f2f272a0e40/)

### Некоторые пояснения
Иногда ключ состоит из двух столбцов. Это сделано для того, чтобы в таблицу нельзя было включить одинаковые записи. Для создания таблицы с двумя ключами используется код:
```SQL
CREATE TABLE step_keyword (
    step_id INT,
    keyword_id INT,
    PRIMARY KEY (step_id, keyword_id),
    FOREIGN KEY (step_id)  REFERENCES step (step_id) ON DELETE CASCADE,
    FOREIGN KEY (keyword_id)  REFERENCES keyword (keyword_id) ON DELETE CASCADE
);
```
#### Работа с датами
Формате  **Unix-время**, в котором хранится количество секунд, прошедших с 1 января 1970 года.

Для перевода к привычному типу `DATE` используется формула:
```
1970-01-01 + time_unix / 86400
```
В SQL для перевода удобно использовать функцию  
```SQL
FROM_UNIXTIME(time_unix)
```
[:arrow_up:Оглавление](#Оглавление)


## Задание Step 2
Отобрать все шаги, в которых рассматриваются вложенные запросы (то есть в названии шага упоминаются вложенные запросы). Указать к какому уроку и модулю они относятся. Для этого вывести 3 поля:
* в поле `Модуль` указать номер модуля и его название через пробел;
* в поле `Урок` указать номер модуля, порядковый номер урока (`lesson_position`) через точку и название урока через пробел;
* в поле `Шаг` указать номер модуля, порядковый номер урока (`lesson_position`) через точку, порядковый номер шага (`step_position`) через точку и название шага через пробел.

Длину полей Модуль и Урок ограничить 19 символами, при этом слишком длинные надписи обозначить многоточием в конце (16 символов - это номер модуля или урока, пробел и  название Урока или Модуля к ним присоединить "..."). Информацию отсортировать по возрастанию номеров модулей, порядковых номеров уроков и порядковых номеров шагов.
```SQL
SELECT 
      CONCAT(
            LEFT(CONCAT(module_id, ' ', module_name), 16), 
            '...') AS Модуль,
      CONCAT(
            LEFT(CONCAT(module_id, '.', lesson_position, ' ', lesson_name), 16), 
            '...') AS Урок,

                 CONCAT(module_id, '.', lesson_position, '.', step_position, ' ', step_name) 
                   AS Шаг
FROM       module
INNER JOIN lesson USING(module_id)
INNER JOIN step   USING(lesson_id)
WHERE step_name LIKE '%ложен%запрос%'
ORDER BY module_id, lesson_position, step_position
```
```
+---------------------+---------------------+-------------------------------------------------------------+
| Модуль              | Урок                | Шаг                                                         |
+---------------------+---------------------+-------------------------------------------------------------+
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.2 Вложенный запрос, возвращающий одно значение          |
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.3 Использование вложенного запроса в выражении          |
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.4 Вложенный запрос, оператор IN                         |
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.5 Вложенный запрос, операторы ANY и ALL                 |
| 1 Основы реляцио... | 1.4 Вложенные за... | 1.4.6 Вложенный запрос после SELECT                         |
| 1 Основы реляцио... | 1.5 Запросы корр... | 1.5.5 Добавление записей, вложенные запросы                 |
| 2 Запросы SQL к ... | 2.2 Запросы на в... | 2.2.7 Запросы для нескольких таблиц со вложенными запросами |
| 2 Запросы SQL к ... | 2.2 Запросы на в... | 2.2.8 Вложенные запросы в операторах соединения             |
| 2 Запросы SQL к ... | 2.3 Запросы корр... | 2.3.5 Запрос на обновление, вложенные запросы               |
+---------------------+---------------------+-------------------------------------------------------------+
```
Вариант с учетом того, что длина названия модуля или урока в общем случае может и не превышать 19
```SQL
SET @limit = 19;
WITH steps AS
(
    SELECT
        module_id, lesson_id, lesson_position, step_id, step_position,
        CONCAT(module_id, ' ' , module_name) AS Модуль,
        CONCAT(module_id, '.', lesson_position, ' ' , lesson_name) AS Урок,
        CONCAT(module_id, '.', lesson_position, '.', step_position, ' ' , step_name) AS Шаг
    FROM
        module
        INNER JOIN lesson USING (module_id)
        INNER JOIN step   USING (lesson_id)
    WHERE LOWER(step_name) LIKE '%вложенн% запрос%'
)
SELECT
    IF(LENGTH(Модуль) <= @limit, Модуль, CONCAT(LEFT(Модуль, @limit-3), '...')) AS Модуль,
    IF(LENGTH(Урок)   <= @limit,   Урок, CONCAT(LEFT(  Урок, @limit-3), '...')) AS Урок,
    Шаг
FROM  steps
ORDER BY module_id, lesson_position, step_position;
```
[:arrow_up:Оглавление](#Оглавление)

## Вхождение символов в строки, регулярные выражения. `REGEXP`, `INSTR`, `REGEXP_INSTR`.
### `REGEXP`
`REGEXP` позволяет задать регулярное выражение, которому должно соответствовать значение столбца. В этом плане `REGEXP` представляет более изощренный и комплексный способ фильтрации, нежели оператор `LIKE`. Это [ссылка на документацию](https://dev.mysql.com/doc/refman/8.0/en/regexp.html#regexp-syntax).

`REGEXP` имеет похожий синтаксис:
```SQL
WHERE выражение [NOT] REGEXP регулярное выражение
```
Регулярное выражение может принимать следующие специальные символы:
* `^` указывает на начало строки
* `$` указывает на конец строки
* `.` соответствует любому одиночному символу
* `[символы]` соответствует любому одиночному символу из квадратных скобок
* `[начальный_символ-конечный_символ]` соответствует любому одиночному символу из диапазона символов
* `|` отделяет два шаблона строки, и значение должно соответствовать одному из этих шаблонов
* `\\b` cимвол конца слова - проверит на то, есть ли пробел, запятая, начало или конец строки и так далее.

Функция `REGEXP` возвращает булевое значение(true/false), если что-то нашла.

Примеры `REGEXP`:

`WHERE ProductName REGEXP 'Phone'`: строка должна содержать "Phone", например, `iPhone X`, `Nokia Phone N`, `iPhone`

`WHERE ProductName REGEXP '^Phone'`: строка должна начинаться с "Phone", например, `Phone 34`, `PhoneX`

`WHERE ProductName REGEXP 'Phone$'`: строка должна заканчиваться на "Phone", например, `iPhone`, `Nokia Phone`

`WHERE ProductName REGEXP 'iPhone [78]'`: строка должна содержать либо `iPhone 7`, либо `iPhone 8`

`WHERE ProductName REGEXP 'iPhone [6-8]'`: строка должна содержать либо `iPhone 6`, либо `iPhone 7`, либо `iPhone 8`

Например, найдем товары, названия которых содержат либо "Phone", либо "Galaxy":
```SQL
SELECT * FROM Products
WHERE ProductName REGEXP 'Phone|Galaxy';
``` 
### `INSTR()`
Чтобы проверить, есть ли слово в строке, можно использовать функцию:
```SQL
INSTR(string, word)
```
которая возвращает позицию первого вхождения `word` в `string`. Если вхождения нет - результат функции 0.
### `REGEXP_INSTR()`
`REGEXP_INSTR(string, word)` делает то же самое, что и `INSTR(string, word)`, только вторым аргументом можно подставить регулярное выражение.

[:arrow_up:Оглавление](#Оглавление)

## Задание Step 3
Заполнить таблицу `step_keyword` следующим образом: если ключевое слово есть в названии шага, то включить в `step_keyword` строку с id шага и id ключевого слова.

Обратите внимание, что некоторые ключевые слова, например `IN`, входят в `INNER` и `JOIN`. Нужно учитывать только отдельные слова, которые разделены в названии шага либо пробелом, либо запятой, либо открывающей скобкой.
```SQL
INSERT INTO step_keyword
SELECT step_id  , keyword_id
FROM step
CROSS JOIN keyword
WHERE REGEXP_INSTR(step_name, CONCAT('\\b', keyword_name, '\\b')) <> 0;
```
<details>
<summary>Результат</summary>
<blockquote>
Это не итоговая таблица. Она просто визуально показывает, правильно ли будет сформирована итоговая.
<tt>
+--------------------------------------------------------------+--------------+
| step_name                                                    | keyword_name |
+--------------------------------------------------------------+--------------+
| Вложенный запрос после SELECT                                | SELECT       |
| Соединение INNER JOIN                                        | INNER        |
| Внешнее соединение LEFT и RIGHT OUTER JOIN                   | LEFT         |
| Внешнее соединение LEFT и RIGHT OUTER JOIN                   | RIGHT        |
| Внешнее соединение LEFT и RIGHT OUTER JOIN                   | OUTER        |
| Соединение INNER JOIN                                        | JOIN         |
| Внешнее соединение LEFT и RIGHT OUTER JOIN                   | JOIN         |
| Перекрестное соединение CROSS JOIN                           | JOIN         |
| Перекрестное соединение CROSS JOIN                           | CROSS        |
| Выборка данных по условию, групповые функции, WHERE и HAVING | WHERE        |
| Выборка данных по условию, групповые функции, WHERE и HAVING | HAVING       |
| Выборка данных, групповые функции SUM и COUNT                | SUM          |
| Выборка данных, групповые функции MIN, MAX и AVG             | AVG          |
| Выборка данных c вычислением, групповые функции, AVG         | AVG          |
| Выборка данных, групповые функции SUM и COUNT                | COUNT        |
| Выборка данных, групповые функции MIN, MAX и AVG             | MIN          |
| Выборка данных по условию, групповые функции, MIN            | MIN          |
| Выборка данных, групповые функции MIN, MAX и AVG             | MAX          |
| Операция соединение, использование USING()                   | USING        |
| Задание. Работа с архивной таблицей, оператор UNION, часть 1 | UNION        |
| Задание. Работа с архивной таблицей, оператор UNION, часть 2 | UNION        |
| Вложенный запрос, операторы ANY и ALL                        | ALL          |
| Вложенный запрос, операторы ANY и ALL                        | ANY          |
| Выборка данных, операторы BETWEEN, IN                        | IN           |
| Вложенный запрос, оператор IN                                | IN           |
| Выборка данных, оператор LIKE                                | LIKE         |
| Выборка данных, операторы BETWEEN, IN                        | BETWEEN      |
+--------------------------------------------------------------+--------------+
</tt>
Итоговая таблица:
<tt>
Affected rows: 27
Query result: step_keyword
+---------+------------+
| step_id | keyword_id |
+---------+------------+
| 38      | 1          |
| 81      | 3          |
| 82      | 4          |
| 82      | 5          |
| 82      | 6          |
| 81      | 7          |
| 82      | 7          |
| 83      | 7          |
| 83      | 8          |
| 47      | 10         |
| 47      | 11         |
| 42      | 15         |
| 43      | 16         |
| 44      | 16         |
| 42      | 17         |
| 43      | 18         |
| 46      | 18         |
| 43      | 19         |
| 88      | 26         |
| 112     | 27         |
| 113     | 27         |
| 37      | 28         |
| 37      | 29         |
| 18      | 30         |
| 36      | 30         |
| 19      | 31         |
| 18      | 32         |
+---------+------------+
</tt>
</blockquote>
</details>

## Задание Step 4
Реализовать поиск по ключевым словам. Вывести шаги, с которыми связаны ключевые слова `MAX` и `AVG` одновременно. Для шагов указать id модуля, позицию урока в модуле, позицию шага в уроке через точку, после позиции шага перед заголовком - пробел. Позицию шага в уроке вывести в виде двух цифр (если позиция шага меньше 10, то перед цифрой поставить 0). Столбец назвать `Шаг`. Информацию отсортировать по первому столбцу в алфавитном порядке.
```SQL
SELECT CONCAT(
    module_id, '.', 
    lesson_position, '.', 
    IF(step_position < 10, CONCAT('0', step_position), step_position), ' ',
    step_name ) AS Шаг
FROM
    (
        SELECT step_id 
        FROM step_keyword AS sk
        INNER JOIN keyword AS k ON k.keyword_id = sk.keyword_id 
                               AND k.keyword_name = 'MAX'
    ) t1
CROSS JOIN
    (
        SELECT step_id 
        FROM step_keyword AS sk
        INNER JOIN keyword AS k ON k.keyword_id = sk.keyword_id 
                               AND k.keyword_name = 'AVG'
    ) t2
    ON t1.step_id = t2.step_id
INNER JOIN step ON t1.step_id = step.step_id
INNER JOIN lesson USING(lesson_id)
INNER JOIN module USING(module_id) 
ORDER BY Шаг;
```
```
+---------------------------------------------------------+
| Шаг                                                     |
+---------------------------------------------------------+
| 1.3.04 Выборка данных, групповые функции MIN, MAX и AVG |
| 1.4.06 Вложенный запрос после SELECT                    |
+---------------------------------------------------------+
```
Альтернатива:
```SQL
SELECT 
    concat(module_id,'.',lesson_position,
           IF(step_position < 10, ".0","."),
           step_position," ",step_name) AS Шаг
FROM
   step
   JOIN lesson USING(lesson_id)
   JOIN module USING(module_id)
   JOIN step_keyword USING (step_id)
   JOIN keyword USING(keyword_id)
WHERE keyword_name = 'MAX' OR keyword_name ='AVG'
GROUP BY ШАГ
HAVING COUNT(*) = 2
ORDER BY 1;
```
[:arrow_up:Оглавление](#Оглавление)

## Выборка данных по нескольким условиям, оператор `CASE`
С помощью оператора `CASE` можно в зависимости от нескольких условий получить один из нескольких результатов.

Оператор `CASE` записывается в виде:
```SQL
CASE  
     WHEN логическое_выражение_1 THEN выражение_1
     WHEN логическое_выражение_2 THEN выражение_2
     ...
     ELSE выражение_else   
END  
```
Раздел `ELSE` является необязательным.

`CASE` можно использовать в  `SELECT`, `UPDATE`, `DELETE`, `SET`, `WHERE`, `ORDER BY`, `HAVING` - всюду, где можно использовать выражения.

Если логическое выражения во всех `WHEN` представляет собой сравнение на равенство с некоторым значением, то оператор `CASE` можно записать в виде:
```SQL
CASE столбец 
     WHEN значение_1 THEN выражение_1
     WHEN значение_2 THEN выражение_2
     ...
     ELSE значение_else   
END  
```
**Пример**

Отнести каждого студента к группе,  в зависимости от пройденных заданий:
```
Интервал	  Группа
от 0 до 10	  I
от 11 до 15	  II
от 16 до 27	  III
больше 27	  IV
```
Пройденными считаются задания с хотя бы одним верным ответом. В таблице `step_student` сохраняются все попытки пользователей, следовательно, могут быть пользователи, у которых на одно задание есть несколько верных попыток.

 Фрагмент логической схемы базы данных:
 
![pic-step-student](https://ucarecdn.com/e32cf2e7-200e-4ba9-9a7c-86244317d7fb/)

*Шаг 1*. Выведем всех студентов и все шаги, которые они прошли с результатом "correct". Этот шаг обязателен, чтобы не учитывать  правильные решения несколько раз.
```SQL
SELECT student_name, step_id
FROM 
    student 
    INNER JOIN step_student USING(student_id)
WHERE result = "correct"
GROUP BY student_name, step_id;
```
<details>
<summary>Результат</summary>
<tt><blockquote>
Query result:
+--------------+---------+
| student_name | step_id |
+--------------+---------+
| student_52   | 10      |
| student_11   | 10      |
| student_19   | 10      |
| student_4    | 10      |
| student_5    | 10      |
| student_53   | 10      |
| student_39   | 10      |
| student_32   | 10      |
| student_61   | 10      |
| student_43   | 10      |
| student_13   | 10      |
| student_57   | 10      |
             ...
+--------------+---------+
Affected rows: 1126.
</blockquote></tt>
</details>

*Шаг 2*. Посчитаем, сколько шагов прошел каждый студент.
```SQL
SELECT student_name, count(*) as rate
FROM 
    (
     SELECT student_name, step_id
     FROM 
         student 
         INNER JOIN step_student USING(student_id)
     WHERE result = "correct"
     GROUP BY student_name, step_id
    ) query_in
GROUP BY student_name
ORDER BY 2;
```
<details>
<summary>Результат</summary>
<tt><blockquote>
+--------------+------+
| student_name | rate |
+--------------+------+
| student_29   | 8    |
| student_47   | 8    |
| student_16   | 9    |
| student_5    | 9    |
| student_63   | 9    |
| student_33   | 10   |
| student_17   | 10   |
| student_64   | 10   |
            ...
+--------------+------+
Affected rows: 64
</blockquote></tt>
</details>

*Шаг 3*. Отнести каждого студента к группе в зависимости от пройденных шагов.
```SQL
SELECT student_name, rate, 
    CASE
        WHEN rate <= 10 THEN "I"
        WHEN rate <= 15 THEN "II"
        WHEN rate <= 27 THEN "III"
        ELSE "IV"
    END AS Группа
FROM      
    (
     SELECT student_name, count(*) as rate
     FROM 
         (
          SELECT student_name, step_id
          FROM 
              student 
              INNER JOIN step_student USING(student_id)
          WHERE result = "correct"
          GROUP BY student_name, step_id
         ) query_in
     GROUP BY student_name 
     ORDER BY 2
    ) query_in_1;
```
```
Query result:
+--------------+------+--------+
| student_name | rate | Группа |
+--------------+------+--------+
| student_29   | 8    | I      |
| student_47   | 8    | I      |
| student_16   | 9    | I      |
| student_5    | 9    | I      |
| student_63   | 9    | I      |
| student_33   | 10   | I      |
| student_17   | 10   | I      |
| student_64   | 10   | I      |
| student_58   | 10   | I      |
| student_38   | 10   | I      |
| student_12   | 11   | II     |
| student_10   | 11   | II     |
              ...
+--------------+------+--------+
Affected rows: 64
```
[:arrow_up:Оглавление](#Оглавление)

## Задание Step 5
Посчитать, сколько студентов относится к каждой группе. Столбцы назвать `Группа`, `Интервал`, `Количество`. Указать границы интервала.
```SQL
SELECT 
       CASE
            WHEN rate <= 10 THEN "I"
            WHEN rate <= 15 THEN "II"
            WHEN rate <= 27 THEN "III"
            ELSE "IV"
       END AS Группа,
       CASE
            WHEN rate <= 10 THEN "от 0 до 10"
            WHEN rate <= 15 THEN "от 11 до 15"
            WHEN rate <= 27 THEN "от 16 до 27"
            ELSE "больше 27"
       END AS Интервал,
       COUNT(rate) AS Количество
FROM
     (
        SELECT student_name, COUNT(student_name) AS rate
        FROM
            (
                SELECT student_name, step_id
                FROM step_student
                INNER JOIN student USING(student_id)
                WHERE result = "correct"
                GROUP BY student_name, step_id
            ) AS t1
        GROUP BY student_name

    ) AS t2
GROUP BY Группа, Интервал
ORDER BY Группа;
```
```
+--------+-------------+------------+
| Группа | Интервал    | Количество |
+--------+-------------+------------+
| I      | от 0 до 10  | 10         |
| II     | от 11 до 15 | 27         |
| III    | от 16 до 27 | 9          |
| IV     | больше 27   | 18         |
+--------+-------------+------------+
```
Это задание можно решить и другим способом (без  `CASE`). Для этого можно создать таблицу с интервалами и использовать ее в запросе.

[:arrow_up:Оглавление](#Оглавление)

## Табличные выражения, оператор `WITH`
Табличное выражение определяется с помощью оператора `WITH` и является частью запроса. Его синтаксис: 
```SQL
WITH имя_выражения (имя_1, имя_2,...)
  AS
    (
     SELECT столбец_1, столбец_2, ...
     FROM 
       ... 
     )
SELECT ...
   FROM имя_выражения
   ...
```
В табличном выражении определяется запрос, результат которого нужно использовать в основной части запроса после `SELECT`. При этом основной запрос может обратиться к столбцам результата табличного выражения через имена, заданные в заголовке `WITH`. При этом количество имен должно совпадать с количеством результирующих столбцов табличного выражения.

В одном запросе может быть несколько табличных выражений. При этом в каждом табличном выражении можно использовать все предшествующие ему табличные выражения.

В табличном выражении необязательно давать имена столбцам результата. В этом случае в основном запросе можно использовать имена столбцов, указанных после `SELECT` в табличном выражении. При наличии одинаковых имен в нескольких табличных выражениях необходимо использовать полное имя столбца (имя табличного выражения, точка, имя столбца).

### Алгоритм, по которому можно отлаживать запрос с табличными выражениями.

1. Оформляем первый шаг алгоритма запроса  (который раньше реализовывался вложенным запросом) в виде табличного выражения
```SQL
WITH first_step (var_1, var_2, var_3) 
  AS 
  (SELECT поле_1, поле_2, поле_3
   ...
   )
```
2. Пишем основной запрос, который выводит результат этого выражения
```SQL
WITH first_step (var_1_1, var_1_2, var_1_3) 
  AS 
  (SELECT поле_1_1, поле_1_2, поле_1_3
   ...
   )
SELECT * FROM first_step
/*
  либо выводим каждое поле табличного выражения
  SELECT var_1_1, var_1_2, var_1_3  FROM first_step
*/
```
3. Пишем следующий шаг алгоритма запроса и проверяем его:
```SQL
WITH first_step (var_1_1, var_1_2, var_1_3) 
  AS 
  (SELECT поле_1_1, поле_1_2, поле_1_3
   ...
   ),
  second_step (var_2_1, var_2_2, var_2_3) 
  AS 
  (SELECT поле_2_1, поле_2_2, поле_2_3
   ...
   )
SELECT * FROM second_step
/*
  либо выводим каждое поле табличного вырвжения
  SELECT var_2_1, var_2_2, var_2_3  FROM second_step
*/
```
4. И так далее.... Также учитываем, что в любом следующем табличном выражении можно использовать предыдущее. 

**Пример**

Для каждого шага вывести процент правильных решений. Информацию упорядочить по возрастанию процента верных решений. Столбцы результата назвать `Шаг` и `Успешность`, процент успешных решений округлить до целого.

Важно. Только для этого задания для одного из шагов установлено, что все ответы пользователей - неверные.

*Шаг 1*. Создадим запрос, который для каждого шага вычисляет количество правильных ответов, данных пользователями.
```SQL
SELECT step_name, count(*)
FROM 
    step 
    INNER JOIN step_student USING (step_id)
WHERE result = "correct"
GROUP BY step_name;
```
Результат:
```
+---------------------------------------------------------------+----------+
| step_name                                                     | count(*) |
+---------------------------------------------------------------+----------+
| Выборка всех данных из таблицы                                | 66       |
| Выборка отдельных столбцов                                    | 65       |
| Выборка отдельных столбцов и присвоение им новых имен         | 66       |
| Выборка данных с созданием вычисляемого столбца               | 64       |
| Выборка данных, вычисляемые столбцы, математические функции   | 66       |
                           ...
+---------------------------------------------------------------+----------+
Affected rows: 31
```
*Шаг 2*. Создадим запрос, который для каждого шага вычисляет количество неверных ответов, данных пользователями.
```SQL
SELECT step_name, count(*)
FROM 
    step 
    INNER JOIN step_student USING (step_id)
WHERE result = "wrong"
GROUP BY step_name;
```
Результат:
```
+---------------------------------------------------------------+----------+
| step_name                                                     | count(*) |
+---------------------------------------------------------------+----------+
| Выборка всех данных из таблицы                                | 10       |
| Выборка отдельных столбцов                                    | 20       |
| Выборка отдельных столбцов и присвоение им новых имен         | 13       |
| Выборка данных с созданием вычисляемого столбца               | 23       |
                           ...
+---------------------------------------------------------------+----------+
Affected rows: 30
```
*Шаг 3*. Создадим запрос с табличными выражениями, который вычисляет процент верных решений. Запрос первого шага включим как табличное выражение с именем `get_count_correct`, запрос второго шага - как табличное выражение `get_count_wrong`.
```SQL
WITH get_count_correct (st_n_c, count_correct) 
  AS (
      SELECT step_name, count(*)
      FROM 
          step 
          INNER JOIN step_student USING (step_id)
      WHERE result = "correct"
      GROUP BY step_name
    ),
  get_count_wrong (st_n_w, count_wrong) 
  AS (
    SELECT step_name, count(*)
    FROM 
        step 
        INNER JOIN step_student USING (step_id)
    WHERE result = "wrong"
    GROUP BY step_name
   )  
SELECT st_n_c AS Шаг, 
    ROUND(count_correct / (count_correct + count_wrong) * 100) AS Успешность
FROM  
    get_count_correct 
    INNER JOIN get_count_wrong ON st_n_c = st_n_w
```
```
+--------------------------------------------------------------------------+------------+
| Шаг                                                                      | Успешность |
+--------------------------------------------------------------------------+------------+
| Выборка данных, оператор LIKE                                            | 19         |
| Вложенные запросы в операторах соединения                                | 32         |
| Задание. Вывести самый популярный жанр                                   | 33         |
| Запросы для нескольких таблиц с группировкой                             | 33         |
                              ...
+--------------------------------------------------------------------------+------------+
Affected rows: 30
```
*Шаг 4*. Обратите внимание, что всего вопросов в таблице 32,  но запрос первого шага вывел общее количество вопросов - 31, а запрос второго шага - 30. Это значит, что на одно задание все пользователи дали неверный ответ, а на два -  все пользователи дали верный ответ. 

Следовательно, нужно вместо внутреннего соединения `INNER JOIN` применить полное внешнее соединение `FULL JOIN`. Это соединение в MySQL не поддерживается, его можно реализовать запросами с `LEFT` и `RIGHT JOIN`, соединенных оператором `UNION`:
```SQL
SELECT ...
   FROM таблица_1 LEFT JOIN таблица_2 ON ...
...
UNION
SELECT ...
   FROM таблица_1 RIGHT JOIN таблица_2 ON ...
...
```
Запрос:
```SQL
WITH get_count_correct (st_n_c, count_correct) 
  AS (
    SELECT step_name, count(*)
    FROM 
        step 
        INNER JOIN step_student USING (step_id)
    WHERE result = "correct"
    GROUP BY step_name
   ),
  get_count_wrong (st_n_w, count_wrong) 
  AS (
    SELECT step_name, count(*)
    FROM 
        step 
        INNER JOIN step_student USING (step_id)
    WHERE result = "wrong"
    GROUP BY step_name
   )  
SELECT st_n_c AS Шаг,
    ROUND(count_correct / (count_correct + count_wrong) * 100) AS Успешность
FROM  
    get_count_correct 
    LEFT JOIN get_count_wrong ON st_n_c = st_n_w
UNION
SELECT st_n_w AS Шаг,
    ROUND(count_correct / (count_correct + count_wrong) * 100) AS Успешность
FROM  
    get_count_correct 
    RIGHT JOIN get_count_wrong ON st_n_c = st_n_w
ORDER BY 2 ;
```
Результат:
```
+--------------------------------------------------------------------------+------------+
| Шаг                                                                      | Успешность |
+--------------------------------------------------------------------------+------------+
| Задание. Работа с архивной таблицей, оператор UNION, часть 1             | None       |
| Задание. Работа с архивной таблицей, оператор UNION, часть 2             | None       |
| Построение логической схемы базы данных                                  | None       |
| Выборка данных, оператор LIKE                                            | 19         |
| Вложенные запросы в операторах соединения                                | 32         |
| Задание. Вывести самый популярный жанр                                   | 33         |
| Запросы для нескольких таблиц с группировкой                             | 33         |     
                              ...
+--------------------------------------------------------------------------+------------+
Affected rows: 32
```
Процент успешных попыток для тех шагов, которые не имеют неверных ответов  или не имеют верных - `Null`, а должно быть 100% и 0%  соответственно. Это произошло из-за того, что при внешнем соединении, вместо отсутствующего значения в результат подставляется `Null`.

[:arrow_up:Оглавление](#Оглавление)

## Задание Step 6
Исправить запрос примера так: для шагов, которые  не имеют неверных ответов, указать 100 как процент успешных попыток, если же шаг не имеет верных ответов, указать 0. Информацию отсортировать сначала по возрастанию успешности, а затем по названию шага в алфавитном порядке.

К таблице верных ответов сначала делаем левый джоин неверных ответов: если неверных ответов `Null`, тогда успешность 100%.
Потом к таблице верных ответов сначала делаем правый джоин неверных ответов: если верных ответов `Null`, тогда успешность 0%.
```SQL
WITH get_count_correct (st_n_c, count_correct) 
  AS (
    SELECT step_name, count(*)
    FROM 
        step 
        INNER JOIN step_student USING (step_id)
    WHERE result = "correct"
    GROUP BY step_name
   ),
  get_count_wrong (st_n_w, count_wrong) 
  AS (
    SELECT step_name, count(*)
    FROM 
        step 
        INNER JOIN step_student USING (step_id)
    WHERE result = "wrong"
    GROUP BY step_name
   )  
SELECT st_n_c AS Шаг,
       IF(count_wrong IS NULL, 100,
          ROUND(count_correct / (count_correct + count_wrong) * 100)
         ) AS Успешность
FROM  
    get_count_correct 
    LEFT JOIN get_count_wrong ON st_n_c = st_n_w
UNION
SELECT st_n_w AS Шаг,
       IF(count_correct IS NULL, 0,
          ROUND(count_correct / (count_correct + count_wrong) * 100)
         ) AS Успешность
FROM  
    get_count_correct 
    RIGHT JOIN get_count_wrong ON st_n_c = st_n_w
ORDER BY Успешность, Шаг ;
```
```
+--------------------------------------------------------------------------+------------+
| Шаг                                                                      | Успешность |
+--------------------------------------------------------------------------+------------+
| Задание. Работа с архивной таблицей, оператор UNION, часть 1             | None       |
| Задание. Работа с архивной таблицей, оператор UNION, часть 2             | None       |
| Построение логической схемы базы данных                                  | None       |
| Выборка данных, оператор LIKE                                            | 19         |
| Вложенные запросы в операторах соединения                                | 32         |
| Задание. Вывести самый популярный жанр                                   | 33         |
| Запросы для нескольких таблиц с группировкой                             | 33         |     
                              ...
+--------------------------------------------------------------------------+------------+
Affected rows: 32
```
Более короткое решение:
```SQL
WITH tt1 AS (
    SELECT 
       step_name,
       SUM(CASE result WHEN 'correct' THEN 1 ELSE 0 END) c_c,
       SUM(CASE result WHEN 'wrong' THEN 1 ELSE 0 END) c_w
    FROM step INNER JOIN step_student USING (step_id)
    GROUP BY step_name
)
SELECT step_name Шаг,
       ROUND(c_c / (c_c + c_w) * 100) Успешность
FROM tt1
ORDER BY 2 ASC,1 ASC;
```
Или даже так:
```SQL
SELECT step_name AS Шаг,  ROUND(AVG(IF (result = 'correct', 1, 0))*100) AS Успешность
FROM step_student
    JOIN step USING (step_id)
GROUP BY step_id
ORDER BY Успешность, Шаг
```
[:arrow_up:Оглавление](#Оглавление)

## Задание Step 7
Вычислить прогресс пользователей по курсу. Прогресс вычисляется как отношение верно пройденных шагов к общему количеству шагов в процентах, округленное до целого. В нашей базе данные о решениях занесены не для всех шагов, поэтому общее количество шагов определить как количество различных шагов в таблице `step_student`.

Тем пользователям, которые прошли все шаги (прогресс = 100%) выдать "Сертификат с отличием". Тем, у кого прогресс больше или равен 80% - "Сертификат". Для остальных записей в столбце `Результат` задать пустую строку ("").

Информацию отсортировать по убыванию прогресса, затем по имени пользователя в алфавитном порядке.
```SQL
SET @num_steps = (SELECT COUNT(DISTINCT step_id) FROM step_student);

WITH students_done AS
         (
           SELECT student_id, step_id, result, COUNT(DISTINCT step_id) AS num_attempts
           FROM step_student
           WHERE result = "correct"
           GROUP BY student_id, step_id, result
         )    
SELECT student_name AS Студент, 
       ROUND(COUNT(student_name) / @num_steps * 100) AS Прогресс,
       CASE 
           WHEN ROUND(COUNT(student_name) / @num_steps * 100) = 100 THEN "Сертификат с отличием"
           WHEN ROUND(COUNT(student_name) / @num_steps * 100) > 80  THEN "Сертификат"
           ELSE ""
       END AS Результат
FROM students_done
INNER JOIN student USING(student_id)
GROUP BY student_name
ORDER BY Прогресс DESC, student_name;
```
<details>
<summary>Результат</summary>
<tt><blockquote>
+------------+----------+-----------------------+
| Студент    | Прогресс | Результат             |
+------------+----------+-----------------------+
| student_60 | 100      | Сертификат с отличием |
| student_15 | 94       | Сертификат            |
| student_18 | 94       | Сертификат            |
| student_27 | 94       | Сертификат            |
| student_30 | 94       | Сертификат            |
| student_31 | 94       | Сертификат            |
| student_36 | 94       | Сертификат            |
| student_39 | 94       | Сертификат            |
| student_4  | 94       | Сертификат            |
| student_43 | 94       | Сертификат            |
| student_44 | 94       | Сертификат            |
| student_46 | 94       | Сертификат            |
| student_49 | 94       | Сертификат            |
| student_51 | 94       | Сертификат            |
| student_53 | 94       | Сертификат            |
| student_59 | 91       | Сертификат            |
| student_9  | 91       | Сертификат            |
| student_23 | 88       | Сертификат            |
| student_50 | 84       | Сертификат            |
| student_20 | 78       |                       |
| student_24 | 78       |                       |
| student_52 | 63       |                       |
| student_56 | 63       |                       |
| student_34 | 59       |                       |
| student_40 | 59       |                       |
| student_11 | 50       |                       |
| student_48 | 50       |                       |
| student_42 | 47       |                       |
| student_61 | 44       |                       |
| student_13 | 41       |                       |
| student_26 | 41       |                       |
| student_1  | 34       |                       |
| student_10 | 34       |                       |
| student_12 | 34       |                       |
| student_14 | 34       |                       |
| student_19 | 34       |                       |
| student_2  | 34       |                       |
| student_21 | 34       |                       |
| student_22 | 34       |                       |
| student_25 | 34       |                       |
| student_28 | 34       |                       |
| student_3  | 34       |                       |
| student_32 | 34       |                       |
| student_35 | 34       |                       |
| student_37 | 34       |                       |
| student_41 | 34       |                       |
| student_45 | 34       |                       |
| student_54 | 34       |                       |
| student_55 | 34       |                       |
| student_57 | 34       |                       |
| student_6  | 34       |                       |
| student_62 | 34       |                       |
| student_7  | 34       |                       |
| student_8  | 34       |                       |
| student_17 | 31       |                       |
| student_33 | 31       |                       |
| student_38 | 31       |                       |
| student_58 | 31       |                       |
| student_64 | 31       |                       |
| student_16 | 28       |                       |
| student_5  | 28       |                       |
| student_63 | 28       |                       |
| student_29 | 25       |                       |
| student_47 | 25       |                       |
+------------+----------+-----------------------+
Affected rows: 64
</blockquote></tt>
</details>

Без табличных выражений короче
```SQL
SET @max_progress = (SELECT COUNT(DISTINCT step_id) FROM step_student);
SELECT student_name Студент, ROUND(COUNT(DISTINCT(step_id)) / @max_progress * 100) Прогресс,
CASE
WHEN ROUND(COUNT(DISTINCT(step_id)) / @max_progress * 100) = 100 THEN 'Сертификат с отличием'
WHEN ROUND(COUNT(DISTINCT(step_id)) / @max_progress * 100) >= 80 THEN 'Сертификат'
ELSE ""
END Результат
FROM student JOIN step_student USING(student_id)
WHERE result = 'correct'
GROUP BY 1
ORDER BY 2 DESC, 1;
```
[:arrow_up:Оглавление](#Оглавление)

## Оконные функции, оператор `OVER`, `ORDER BY`
Оконные функции позволяют получить некоторую дополнительную информацию о выборке данных .  С помощью оконных функций можно реализовать вычисления для набора строк, некоторым образом связанных с текущей строкой. При этом использование оконной функции не группирует несколько строк в одну, а сохраняет все строки запроса. Синтаксис оконных функций:
```SQL
название_функции(выражение) 
  OVER (
        PARTITION BY столбец_1, столбец_2, ... - это окно
        ORDER BY ... - сортировка 
        ROWS BETWEEN - границы окна
          ...
  )
```
Причем все разделы `OVER` являются не обязательными, но обязательно нужно указать либо окно, либо сортировку. На данном шаге рассмотрим самый простой синтаксис оконного выражения:
```SQL
название_функции(выражение) 
  OVER (
        ORDER BY ...
  )
```
Такое оконное выражение позволяет выполнять одинаковые действия над всеми записями таблицы (здесь окно - вся таблица). В качестве функций можно использовать:

`ROW_NUMBER()` - просто нумерация строк;

`RANK()` - ранжирование строк - при одинаковом значении строкам присваивается один номер, с пропуском номеров;

`DENSE_RANK()` - ранжирование строк без пропуска номеров;

`LAG()` - выбирает строку, предшествующую текущей, если таковой нет - выдается `NULL`;

`LEAD()` - выбирает строку, следующую за текущей, если таковой нет - выдается `NULL`.

Необязательные параметры функции `LAG()`:
```SQL
LAG(столбец, количество-строк, выражение-если-null)
```
где
`количество-строк` - по умолчанию = 1 (если не указываем, то значение из предыдущей строки, но можем указать любой сдвиг), `выражение-если-null` - по умолчанию `null`, но можем указать любое, которое и будет использовано в дальнейших вычислениях. См. [Задание Step 8](#Задание-Step-8).

**Пример**

Вычислить, сколько шагов прошел пользователь. Ранжировать пользователей по убыванию результатов.
```SQL
SELECT student_name, count(DISTINCT step_id) AS Kоличество,

    ROW_NUMBER() OVER (ORDER BY  count(DISTINCT step_id) DESC) AS Номер

FROM student INNER JOIN step_student USING (student_id)
WHERE result = "correct"
GROUP BY student_name;
```
```
+--------------+------------+-------+
| student_name | Kоличество | Номер |
+--------------+------------+-------+
| student_60   | 32         | 1     |
| student_15   | 30         | 2     |
| student_18   | 30         | 3     |
| student_27   | 30         | 4     |
| student_30   | 30         | 5     |
| student_31   | 30         | 6     |
| student_36   | 30         | 7     |
              ...
| student_5    | 9          | 61    |
| student_63   | 9          | 62    |
| student_29   | 8          | 63    |
| student_47   | 8          | 64    |
+--------------+------------+-------+
Affected rows: 64
```
В этом запросе после того, как были выбраны все студенты, посчитаны их шаги с правильными ответами, с помощью оконной функции была выполнена сортировка по количеству верных шагов (`count(DISTINCT step_id)`)  и пронумерованы строки (функция `ROW_NUMBER()`).

Дополнительно ранжируем студентов.
```SQL
SELECT student_name, count(DISTINCT step_id) AS Kоличество,

    ROW_NUMBER() OVER (ORDER BY  count(DISTINCT step_id) DESC) AS Номер,

    RANK() OVER (ORDER BY  count(DISTINCT step_id) DESC) AS Ранг,
    DENSE_RANK() OVER (ORDER BY  count(DISTINCT step_id) DESC) AS Рейтинг

FROM student INNER JOIN step_student USING (student_id)
WHERE result = "correct"
GROUP BY student_name
```
```
+--------------+------------+-------+------+---------+
| student_name | Kоличество | Номер | Ранг | Рейтинг |
+--------------+------------+-------+------+---------+
| student_60   | 32         | 1     | 1    | 1       |
| student_15   | 30         | 2     | 2    | 2       |
| student_18   | 30         | 3     | 2    | 2       |
| student_27   | 30         | 4     | 2    | 2       |
| student_30   | 30         | 5     | 2    | 2       |
| student_31   | 30         | 6     | 2    | 2       |
| student_36   | 30         | 7     | 2    | 2       |
| student_39   | 30         | 8     | 2    | 2       |
| student_4    | 30         | 9     | 2    | 2       |
| student_43   | 30         | 10    | 2    | 2       |
| student_44   | 30         | 11    | 2    | 2       |
| student_46   | 30         | 12    | 2    | 2       |
| student_49   | 30         | 13    | 2    | 2       |
| student_51   | 30         | 14    | 2    | 2       |
| student_53   | 30         | 15    | 2    | 2       |
| student_59   | 29         | 16    | 16   | 3       |
| student_9    | 29         | 17    | 16   | 3       |
| student_23   | 28         | 18    | 18   | 4       |
| student_50   | 27         | 19    | 19   | 5       |
                        ...
| student_5    | 9          | 61    | 60   | 15      |
| student_63   | 9          | 62    | 60   | 15      |
| student_29   | 8          | 63    | 63   | 16      |
| student_47   | 8          | 64    | 63   | 16      |
+--------------+------------+-------+------+---------+
Affected rows: 64
```
С помощью функции `RANK()` и `DENSE_RANK()` все студенты, имеющие 30  верно пройденных шагов, получили ранг 2 и  рейтинг 2. Студентам с 29 балами присвоен ранг 16 и  рейтинг 3.

**Пример**

Для каждого студента указать, на сколько меньше он прошел шагов, чем идущий перед ним по рейтингу студент.
```SQL
SELECT student_name, count(DISTINCT step_id) AS Количество,

       LAG(count(DISTINCT step_id)) 
       OVER (ORDER BY  count(DISTINCT step_id) DESC) - count(DISTINCT step_id) AS Разница

FROM student INNER JOIN step_student USING (student_id)
WHERE result = "correct"
GROUP BY student_name
```
```
+--------------+------------+---------+
| student_name | Количество | Разница |
+--------------+------------+---------+
| student_60   | 32         | None    |
| student_15   | 30         | 2       |
| student_18   | 30         | 0       |
| student_27   | 30         | 0       |
| student_30   | 30         | 0       |
| student_31   | 30         | 0       |
| student_36   | 30         | 0       |

| student_63   | 9          | 0       |
| student_29   | 8          | 1       |
| student_47   | 8          | 0       |
+--------------+------------+---------+
Affected rows: 64
```
Так как у первой записи нет предыдущей - значение разницы `NULL`. Заменим ее на 0 с помощью функции:
```SQL
IFNULL(выражение, результат)
```
которая возвращает `результат`, если `выражение` равно `NULL`, и само выражение в противном случае.

Запрос:
```SQL
SELECT student_name, count(DISTINCT step_id) AS Количество,

       IFNULL(LAG(count(DISTINCT step_id)) 
              OVER (ORDER BY  count(DISTINCT step_id) DESC) - count(DISTINCT step_id), 
              0) AS Разница

FROM student INNER JOIN step_student USING (student_id)
WHERE result = "correct"
GROUP BY student_name
```
```
+--------------+------------+---------+
| student_name | Количество | Разница |
+--------------+------------+---------+
| student_60   | 32         | 0       |
| student_15   | 30         | 2       |
| student_18   | 30         | 0       |
| student_27   | 30         | 0       |
| student_30   | 30         | 0       |
| student_31   | 30         | 0       |
| student_36   | 30         | 0       |
              ...
| student_63   | 9          | 0       |
| student_29   | 8          | 1       |
| student_47   | 8          | 0       |
+--------------+------------+---------+
Affected rows: 64
```
[:arrow_up:Оглавление](#Оглавление)

## Задание Step 8
Для студента с именем `student_61` вывести все его попытки: название шага, результат и дату отправки попытки (`submission_time`). Информацию отсортировать по дате отправки попытки и указать, сколько минут прошло между отправкой соседних попыток. Название шага ограничить 20 символами и добавить "...". Столбцы назвать `Студент`, `Шаг`, `Результат`, `Дата_отправки`, `Разница`.

*Пояснение*
 1. Время в таблице `step_student` представлено в формате  Unix-время , в котором хранится количество секунд, прошедших с 1 января 1970 года. Для перевода к привычному виду `DATE` используется формула:
```
1970-01-01 + time_unix / 86400
```
В SQL для перевода удобно использовать функцию  `FROM_UNIXTIME()`.

Например:
```SQL
FROM_UNIXTIME(1598291490) =  2020-08-24 17:51:30
```
2. Для перевода количества секунд во временной формат используется функция `SEC_TO_TIME()`, например:
```SQL
SEC_TO_TIME(288) = 0:04:48
```
Решение:
```SQL
SELECT student_name AS Студент, 
       CONCAT(LEFT(step_name, 20), "...") AS Шаг, 
       result AS Результат, 
       FROM_UNIXTIME(submission_time) AS Дата_отправки, 
       SEC_TO_TIME(
           submission_time - LAG(submission_time, 1, submission_time) 
                             OVER (ORDER BY submission_time)
                  ) AS Разница
FROM step_student
INNER JOIN student USING(student_id)
INNER JOIN step    USING(step_id)
WHERE student_name = "student_61"
ORDER BY submission_time;
```
```
+------------+-------------------------+-----------+---------------------+------------------+
| Студент    | Шаг                     | Результат | Дата_отправки       | Разница          |
+------------+-------------------------+-----------+---------------------+------------------+
| student_61 | Выборка всех данных ... | correct   | 2020-08-27 14:22:14 | 0:00:00          |
| student_61 | Выборка отдельных ст... | correct   | 2020-08-27 14:23:53 | 0:01:39          |
| student_61 | Выборка отдельных ст... | correct   | 2020-08-27 14:28:41 | 0:04:48          |
| student_61 | Выборка данных с соз... | wrong     | 2020-08-27 14:33:57 | 0:05:16          |
| student_61 | Выборка данных с соз... | wrong     | 2020-08-27 14:34:24 | 0:00:27          |
                                        ...
| student_61 | Выборка данных с сор... | correct   | 2020-08-27 16:14:15 | 0:01:24          |
| student_61 | Соединение INNER JOI... | correct   | 2020-09-01 07:25:39 | 4 days, 15:11:24 |
| student_61 | Внешнее соединение L... | wrong     | 2020-09-01 09:53:30 | 2:27:51          |
| student_61 | Внешнее соединение L... | correct   | 2020-09-01 09:53:50 | 0:00:20          |
| student_61 | Перекрестное соедине... | wrong     | 2020-09-01 10:45:30 | 0:51:40          |
| student_61 | Перекрестное соедине... | wrong     | 2020-09-01 10:46:21 | 0:00:51          |
| student_61 | Перекрестное соедине... | correct   | 2020-09-01 10:47:55 | 0:01:34          |
+------------+-------------------------+-----------+---------------------+------------------+
Affected rows: 43
```
[:arrow_up:Оглавление](#Оглавление)

## Задание Step 9
Посчитать среднее время, за которое пользователи проходят урок по следующему алгоритму:

* для каждого пользователя вычислить время прохождения шага как сумму времени, потраченного на каждую попытку (время попытки - это разница между временем отправки задания и временем начала попытки), при этом попытки, которые длились больше 4 часов не учитывать, так как пользователь мог просто оставить задание открытым в браузере, а вернуться к нему на следующий день;
* для каждого студента посчитать общее время, которое он затратил на каждый урок;
* вычислить среднее время выполнения урока в часах, результат округлить до 2-х знаков после запятой;
* вывести информацию по возрастанию времени, пронумеровав строки, для каждого урока указать номер модуля и его позицию в нем.

Столбцы результата назвать `Номер`, `Урок`, `Среднее_время`.

Считаем время прохождения каждого шага разными студентами:
```SQL
SELECT step_id, student_id,
        SEC_TO_TIME(SUM(submission_time - attempt_time)) AS Время
FROM step_student
WHERE (submission_time - attempt_time) < 4*60*60
GROUP BY student_id, step_id
ORDER BY student_id, step_id;
```
<details>
<summary>Результат</summary>
<tt><blockquote>
+---------+------------+---------+
| step_id | student_id | Время   |
+---------+------------+---------+
| 10      | 1          | 0:00:56 |
| 11      | 1          | 0:01:20 |
| 12      | 1          | 0:01:28 |
| 13      | 1          | 0:03:26 |
| 14      | 1          | 0:04:35 |
| 15      | 1          | 0:08:02 |
| 17      | 1          | 0:05:04 |
| 18      | 1          | 0:05:49 |
| 19      | 1          | 0:06:24 |
| 20      | 1          | 0:06:31 |
| 10      | 2          | 0:01:25 |
| 11      | 2          | 0:06:02 |
|             ...                |
+---------+------------+---------+
Affected rows: 1037.
</blockquote></tt>
</details>

Мы получили времена выполнения каждого шага, будем использовать их в позапросе `student_step_time`. Проссимируем их, чтобы полусить время выполнения урока для каждых студентов.
```SQL
WITH student_step_time (student_id, step_id, Время) AS
        (
            SELECT student_id,  step_id,
                   SUM(submission_time - attempt_time) AS Время
            FROM step_student
            WHERE (submission_time - attempt_time) < 4*60*60
            GROUP BY student_id,  step_id
        )
SELECT lesson_id, student_id, SEC_TO_TIME(SUM(Время)) AS lesson_time
FROM       student_step_time
INNER JOIN step         USING(step_id)
INNER JOIN lesson       USING(lesson_id)
GROUP BY student_id, lesson_id
ORDER BY student_id, lesson_id;
```
<details>
<summary>Результат</summary>
<tt><blockquote>
+-----------+------------+-------------+
| lesson_id | student_id | lesson_time |
+-----------+------------+-------------+
| 2         | 1          | 0:43:35     |
| 2         | 2          | 0:27:16     |
| 2         | 3          | 1:00:53     |
| 2         | 4          | 3:50:21     |
| 9         | 4          | 3:29:30     |
| 11        | 4          | 4:07:32     |
| 2         | 5          | 1:14:02     |
| 2         | 6          | 5:13:17     |
| 2         | 7          | 4:08:46     |
| 2         | 8          | 1:22:46     |
| 2         | 9          | 3:22:36     |
| 9         | 9          | 2:39:29     |
| 11        | 9          | 2:50:52     |
| 2         | 10         | 1:22:33     |
              ...
+-----------+------------+-------------+
Affected rows: 118.
</blockquote></tt>
</details>

Будем использовать полученный результат как подзапрос `student_lesson_time` для поиска среднего времени прохождения урока, которое запомним в табличное выражение `lesson_mean_time`. Добавим красивое отображение названия урока `CONCAT(module_id, ".", lesson_position, " ", lesson_name) AS Урок` и оконную функцию счетчика строк  `ROW_NUMBER() OVER (ORDER BY Среднее_время) AS Номер`.
```SQL
WITH 
     student_step_time (student_id, step_id, Время) AS
         (
            SELECT student_id,  step_id,
                   SUM(submission_time - attempt_time) AS Время
            FROM step_student
            WHERE (submission_time - attempt_time) < 4*60*60
            GROUP BY student_id,  step_id
         ),
     student_lesson_time (lesson_id, student_id, lesson_time) AS
         (
            SELECT lesson_id, student_id, SUM(Время) AS lesson_time
            FROM       student_step_time
            INNER JOIN step         USING(step_id)
            INNER JOIN lesson       USING(lesson_id)
            GROUP BY student_id, lesson_id             
         ),
     lesson_mean_time (lesson_id, Среднее_время) AS
         (
             SELECT lesson_id, ROUND(AVG(lesson_time) / 3600, 2) AS Среднее_время
             FROM student_lesson_time
             GROUP BY lesson_id
         )
SELECT 
       ROW_NUMBER() OVER (ORDER BY Среднее_время) AS Номер,
       CONCAT(module_id, ".", lesson_position, " ", lesson_name) AS Урок, 
       Среднее_время
FROM 
       lesson_mean_time
       INNER JOIN lesson USING(lesson_id)
       INNER JOIN module USING(module_id)
ORDER BY Среднее_время;
```
```
+-------+-------------------------------------------------------------+---------------+
| Номер | Урок                                                        | Среднее_время |
+-------+-------------------------------------------------------------+---------------+
| 1     | 2.2 Запросы на выборку, соединение таблиц                   | 2.37          |
| 2     | 1.2 Выборка данных                                          | 2.65          |
| 3     | 2.4 База данных "Интернет-магазин книг", запросы на выборку | 3.65          |
+-------+-------------------------------------------------------------+---------------+
```
[:arrow_up:Оглавление](#Оглавление)

## Оконные функции, оператор `OVER`, `PARTITION BY`
Рассмотрим оконную функцию, которая включает два раздела:
```SQL
название_функции(выражение) 
  OVER (
        PARTITION BY ...
        ORDER BY ... 
  )
```
Такое оконное выражение позволяет выполнять одинаковые действия над всеми записями таблицы, ограниченными "окном". Столбцы, образующие окно, записываются после  `PARTITION BY`. Окном считается совокупность записей, имеющих в столбцах, указанных после  `PARTITION BY`, одинаковые значения.

В качестве функций можно использовать те же функции, которые применялись в оконных функциях без указания окна:

`ROW_NUMBER()` - просто нумерация строк внутри окна;

`RANK()` - ранжирование строк внутри окна - при одинаковом значении строкам присваивается один номер, с пропуском номеров;

`DENSE_RANK()` - ранжирование строк внутри окна без пропуска номеров;

`LAG()` - выбирает строку внутри окна, предшествующую текущей, если таковой нет - выдается `NULL`;

`LEAD()` - выбирает строку внутри окна, следующую за текущей, если таковой нет - выдается `NULL`.

**Пример**

Вычислить, сколько шагов прошел пользователь по каждому модулю. Ранжировать пользователей по убыванию результатов и имени в каждом модуле. 

Можно сравнить с прошлым заданием [Step 8](#Задание-Step-8): Вычислить, сколько шагов прошел пользователь. Ранжировать пользователей по убыванию результатов. Не учитывался модуль.

Вначале посчитаем количество выполненых заданий в каждом моделе для каждого студента. А потом уберем это в подзапрос, видимо, для красоты структуры, т.к. можно было бы и без подзапроса. 
```SQL
   SELECT module_id, student_name, count(DISTINCT step_id)
   FROM student INNER JOIN step_student USING(student_id)
                INNER JOIN step USING (step_id)
                INNER JOIN lesson USING (lesson_id)
   WHERE result = "correct"
   GROUP BY module_id, student_name
```
Теперь ранжируем с помощь оконных функций:
```SQL
WITH 
     get_rate_lesson(mod_id, stud, rate) 
       AS (
              SELECT module_id, student_name, count(DISTINCT step_id)
              FROM student INNER JOIN step_student USING(student_id)
                           INNER JOIN step         USING (step_id)
                           INNER JOIN lesson       USING (lesson_id)
              WHERE result = "correct"
              GROUP BY module_id, student_name
          )
SELECT mod_id AS Модуль, stud AS Студент, rate AS Рейтинг,
    ROW_NUMBER() OVER (PARTITION BY mod_id ORDER BY rate DESC, stud) AS Номер,
    RANK()       OVER (PARTITION BY mod_id ORDER BY rate DESC, stud) AS Ранг,
    DENSE_RANK() OVER (PARTITION BY mod_id ORDER BY rate DESC, stud) AS Рейтинг  
FROM get_rate_lesson;
```
```
+--------+------------+---------+-------+------+---------+
| Модуль | Студент    | Рейтинг | Номер | Ранг | Рейтинг |
+--------+------------+---------+-------+------+---------+
| 1      | student_52 | 11      | 1     | 1    | 1       |
| 1      | student_37 | 11      | 2     | 1    | 1       |
| 1      | student_39 | 11      | 3     | 1    | 1       |
| 1      | student_4  | 11      | 4     | 1    | 1       |
| 1      | student_40 | 11      | 5     | 1    | 1       |
                        ...
| 1      | student_29 | 8       | 63    | 63   | 4       |
| 1      | student_47 | 8       | 64    | 63   | 4       |
| 2      | student_60 | 21      | 1     | 1    | 1       |
| 2      | student_43 | 19      | 2     | 2    | 2       |
                        ...
| 2      | student_48 | 5       | 26    | 26   | 9       |
| 2      | student_11 | 5       | 27    | 26   | 9       |
| 2      | student_42 | 4       | 28    | 28   | 10      |
| 2      | student_61 | 3       | 29    | 29   | 11      |
| 2      | student_26 | 2       | 30    | 30   | 12      |
| 2      | student_13 | 2       | 31    | 30   | 12      |
+--------+------------+---------+-------+------+---------+
Affected rows: 95
```
Здесь ранжирование происходит внутри одного модуля. Если же убрать `PARTITION BY` из оконных функций, то номера/ранги/рейтинги пойдут с максимальных значений по _всей_ таблице.
```SQL
SELECT mod_id AS Модуль, stud AS Студент, rate AS Рейтинг,
    ROW_NUMBER() OVER (ORDER BY rate DESC) AS Номер,
    RANK()       OVER (ORDER BY rate DESC) AS Ранг,
    DENSE_RANK() OVER (ORDER BY rate DESC) AS Рейтинг  
FROM get_rate_lesson;
```
<details>
<summary>Результат</summary>
<tt><blockquote>
+--------+------------+---------+-------+------+---------+
| Модуль | Студент    | Рейтинг | Номер | Ранг | Рейтинг |
+--------+------------+---------+-------+------+---------+
| 2      | student_60 | 21      | 1     | 1    | 1       |
| 2      | student_15 | 19      | 2     | 2    | 2       |
| 2      | student_18 | 19      | 3     | 2    | 2       |
| 2      | student_53 | 19      | 4     | 2    | 2       |
| 2      | student_51 | 19      | 5     | 2    | 2       |
| 2      | student_27 | 19      | 6     | 2    | 2       |
| 2      | student_49 | 19      | 7     | 2    | 2       |
| 2      | student_46 | 19      | 8     | 2    | 2       |
| 2      | student_44 | 19      | 9     | 2    | 2       |
| 2      | student_43 | 19      | 10    | 2    | 2       |
| 2      | student_4  | 19      | 11    | 2    | 2       |
| 2      | student_39 | 19      | 12    | 2    | 2       |
| 2      | student_36 | 19      | 13    | 2    | 2       |
| 2      | student_31 | 19      | 14    | 2    | 2       |
| 2      | student_30 | 19      | 15    | 2    | 2       |
| 2      | student_9  | 18      | 16    | 16   | 3       |
| 2      | student_59 | 18      | 17    | 16   | 3       |
| 2      | student_23 | 17      | 18    | 18   | 4       |
| 2      | student_50 | 16      | 19    | 19   | 5       |
| 2      | student_24 | 14      | 20    | 20   | 6       |
| 2      | student_20 | 14      | 21    | 20   | 6       |
| 1      | student_48 | 11      | 22    | 22   | 7       |
| 1      | student_49 | 11      | 23    | 22   | 7       |
| 1      | student_50 | 11      | 24    | 22   | 7       |
| 1      | student_51 | 11      | 25    | 22   | 7       |
| 1      | student_1  | 11      | 26    | 22   | 7       |
                         ...
+--------+------------+---------+-------+------+---------+
Affected rows: 95
</blockquote></tt>
</details>

___

Другой тип функций - это функции, которые используются для вычислений со значениями столбцов, входящих в окно:
```SQL
SUM(), MAX(), MIN(), AVG(), COUNT()
```
По записи они точно соответствуют групповым функциям, при этом вычисленное значение заносится в каждую запись окна. В то время как при использовании группировки возвращается одна запись для каждой группы.

Как правило, эти функции используются в следующем контексте:
```SQL
название_функции(выражение) 
  OVER (
        PARTITION BY ...
  )
```
**Пример**

Посчитать, сколько шагов пройдено пользователями по каждому уроку. Вывести максимальное и минимальное значение пройденных шагов по каждому модулю.
```SQL
WITH get_rate_lesson(mod_id, les, rate) 
       AS (
               SELECT module_id,
                      CONCAT(module_id,'.', lesson_position),
                      count(DISTINCT step_id)
               FROM step_student INNER JOIN step USING (step_id)
                                 INNER JOIN lesson USING (lesson_id)
               WHERE result = "correct"
               GROUP BY module_id, 2
          )
SELECT mod_id AS Модуль, les AS Урок, rate AS Пройдено_шагов, 
    MAX(rate) OVER (PARTITION BY mod_id) AS Максимум_по_модулю,
    MIN(rate) OVER (PARTITION BY mod_id) AS Минимум_по_модулю
FROM get_rate_lesson 
```
```
+--------+------+----------------+--------------------+-------------------+
| Модуль | Урок | Пройдено_шагов | Максимум_по_модулю | Минимум_по_модулю |
+--------+------+----------------+--------------------+-------------------+
| 1      | 1.2  | 11             | 11                 | 11                |
| 2      | 2.2  | 8              | 13                 | 8                 |
| 2      | 2.4  | 13             | 13                 | 8                 |
+--------+------+----------------+--------------------+-------------------+
```
[:arrow_up:Оглавление](#Оглавление)

## Задание Step 10
Вычислить рейтинг каждого студента относительно студента, прошедшего наибольшее количество шагов в модуле (вычисляется как отношение количества пройденных студентом шагов к максимальному количеству пройденных шагов, умноженное на 100). Вывести номер модуля, имя студента, количество пройденных им шагов и относительный рейтинг. Относительный рейтинг округлить до одного знака после запятой. Столбцы назвать `Модуль`, `Студент`, `Пройдено_шагов` и `Относительный_рейтинг`  соответственно. Информацию отсортировать сначала по возрастанию номера модуля, потом по убыванию относительного рейтинга и, наконец, по имени студента в алфавитном порядке.
```SQL
WITH 
     get_rate_lesson(mod_id, stud, rate) 
       AS (
              SELECT module_id, student_name, count(DISTINCT step_id)
              FROM student INNER JOIN step_student USING(student_id)
                           INNER JOIN step         USING (step_id)
                           INNER JOIN lesson       USING (lesson_id)
              WHERE result = "correct"
              GROUP BY module_id, student_name
          )
SELECT mod_id AS Модуль, 
       stud AS Студент, 
       rate AS Пройдено_шагов,
       ROUND(
                100 * rate / MAX(rate) OVER (PARTITION BY mod_id),
                1
            ) AS Относительный_рейтинг
FROM get_rate_lesson
ORDER BY Модуль, Относительный_рейтинг DESC, Студент;
```
```
+--------+------------+----------------+-----------------------+
| Модуль | Студент    | Пройдено_шагов | Относительный_рейтинг |
+--------+------------+----------------+-----------------------+
| 1      | student_1  | 11             | 100.0                 |
| 1      | student_10 | 11             | 100.0                 |
| 1      | student_11 | 11             | 100.0                 |
                              ...
| 1      | student_47 | 8              | 72.7                  |
| 2      | student_60 | 21             | 100.0                 |
| 2      | student_15 | 19             | 90.5                  |
| 2      | student_18 | 19             | 90.5                  |
| 2      | student_27 | 19             | 90.5                  |
| 2      | student_30 | 19             | 90.5                  |
| 2      | student_31 | 19             | 90.5                  |
| 2      | student_36 | 19             | 90.5                  |
| 2      | student_39 | 19             | 90.5                  |
| 2      | student_4  | 19             | 90.5                  |
| 2      | student_43 | 19             | 90.5                  |
| 2      | student_44 | 19             | 90.5                  |
| 2      | student_46 | 19             | 90.5                  |
| 2      | student_49 | 19             | 90.5                  |
                               ...
| 2      | student_48 | 5              | 23.8                  |
| 2      | student_42 | 4              | 19.0                  |
| 2      | student_61 | 3              | 14.3                  |
| 2      | student_13 | 2              | 9.5                   |
| 2      | student_26 | 2              | 9.5                   |
+--------+------------+----------------+-----------------------+
Affected rows: 95
```
[:arrow_up:Оглавление](#Оглавление)


[:arrow_up:Оглавление](#Оглавление)[:arrow_up:Оглавление](#Оглавление)[:arrow_up:Оглавление](#Оглавление)

