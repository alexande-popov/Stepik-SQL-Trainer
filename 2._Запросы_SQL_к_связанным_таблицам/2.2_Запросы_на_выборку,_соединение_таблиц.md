# 2.2 Запросы на выборку, соединение таблиц
В запросах SQL могут участвовать несколько таблиц базы данных. При этом необходимо указать как эти таблицы соединены между собой. 
Операция соединения `JOIN` предназначена для обеспечения выборки данных из двух таблиц и включения этих данных в один результирующий набор. 
При необходимости соединения не двух, а нескольких таблиц, операция соединения применяется несколько раз (последовательно).

Операторы соединения входят в раздел `FROM` SQL запросов.

[Понимание джойнов сломано. Это точно не пересечение кругов, честно](https://habr.com/ru/post/448072/)

[Понимание джойнов сломано. Продолжение. Попытка альтернативной визуализации](https://habr.com/ru/post/450528/)

Изначальные таблицы
```
Таблица genre:
+----------+-------------+
| genre_id | name_genre  |
+----------+-------------+
| 1        | Роман       |
| 2        | Поэзия      |
| 3        | Приключения |
+----------+-------------+

Таблица author:
+-----------+------------------+
| author_id | name_author      |
+-----------+------------------+
| 1         | Булгаков М.А.    |
| 2         | Достоевский Ф.М. |
| 3         | Есенин С.А.      |
| 4         | Пастернак Б.Л.   |
| 5         | Лермонтов М.Ю.   |
+-----------+------------------+

Таблица book:
+---------+-----------------------+-----------+----------+--------+--------+
| book_id | title                 | author_id | genre_id | price  | amount |
+---------+-----------------------+-----------+----------+--------+--------+
| 1       | Мастер и Маргарита    | 1         | 1        | 670.99 | 3      |
| 2       | Белая гвардия         | 1         | 1        | 540.50 | 5      |
| 3       | Идиот                 | 2         | 1        | 460.00 | 10     |
| 4       | Братья Карамазовы     | 2         | 1        | 799.01 | 3      |
| 5       | Игрок                 | 2         | 1        | 480.50 | 10     |
| 6       | Стихотворения и поэмы | 3         | 2        | 650.00 | 15     |
| 7       | Черный человек        | 3         | 2        | 570.20 | 6      |
| 8       | Лирика                | 4         | 2        | 518.99 | 2      |
+---------+-----------------------+-----------+----------+--------+--------+
```
## Соединение `INNER JOIN`
Оператор внутреннего соединения `INNER JOIN` соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является симметричным.
```SQL
SELECT
     ...
FROM
    таблица_1 INNER JOIN  таблица_2
    ON условие
...
```
Результат запроса формируется так:
* каждая строка одной таблицы сопоставляется с каждой строкой второй таблицы;
* для полученной «соединённой» строки проверяется условие соединения;
* если условие истинно, в таблицу результата добавляется соответствующая «соединённая» строка;
* 
**Пример**

Вывести название книг и их авторов.

Запрос:
```SQL
SELECT title, name_author
FROM 
    author INNER JOIN book
    ON author.author_id = book.author_id;
```
```
+-----------------------+------------------+
| title                 | name_author      |
+-----------------------+------------------+
| Мастер и Маргарита    | Булгаков М.А.    |
| Белая гвардия         | Булгаков М.А.    |
| Идиот                 | Достоевский Ф.М. |
| Братья Карамазовы     | Достоевский Ф.М. |
| Игрок                 | Достоевский Ф.М. |
| Стихотворения и поэмы | Есенин С.А.      |
| Черный человек        | Есенин С.А.      |
| Лирика                | Пастернак Б.Л.   |
+-----------------------+------------------+
```
#### Задание
Вывести название, жанр и цену тех книг, количество которых больше 8, в отсортированном по убыванию цены виде.
```SQL
SELECT title, name_genre, price
FROM 
    genre INNER JOIN book
    ON genre.genre_id = book.genre_id
WHERE amount > 8
ORDER BY price DESC;
```
```
+-----------------------+------------+--------+
| title                 | name_genre | price  |
+-----------------------+------------+--------+
| Стихотворения и поэмы | Поэзия     | 650.00 |
| Игрок                 | Роман      | 480.50 |
| Идиот                 | Роман      | 460.00 |
+-----------------------+------------+--------+
```
## Внешнее соединение `LEFT` и `RIGHT OUTER JOIN`
Оператор внешнего соединения `LEFT OUTER JOIN`  (можно использовать `LEFT JOIN`) соединяет две таблицы. 
Порядок таблиц для оператора важен, поскольку оператор не является симметричным.
```SQL
SELECT
     ...
FROM
    таблица_1 LEFT JOIN  таблица_2
    ON условие
...
```
Результат запроса формируется так:

1. в результат включается внутреннее соединение (`INNER JOIN`) первой и второй таблицы в соответствии с условием;
2. затем в результат добавляются те записи первой таблицы, которые не вошли во внутреннее соединение на шаге 1, 
для таких записей соответствующие поля второй таблицы заполняются значениями `NULL`.

Соединение `RIGHT JOIN` действует аналогично, только в пункте 2 первая таблица меняется на вторую и наоборот.

**Пример**

Вывести название всех книг каждого автора, если книг некоторых авторов в данный момент нет на складе – вместо названия книги указать Null.
```SQL
SELECT name_author, title 
FROM author LEFT JOIN book
     ON author.author_id = book.author_id
ORDER BY name_author; 
```
```
+------------------+-----------------------+
| name_author      | title                 |
+------------------+-----------------------+
| Булгаков М.А.    | Мастер и Маргарита    |
| Булгаков М.А.    | Белая гвардия         |
| Достоевский Ф.М. | Игрок                 |
| Достоевский Ф.М. | Идиот                 |
| Достоевский Ф.М. | Братья Карамазовы     |
| Есенин С.А.      | Стихотворения и поэмы |
| Есенин С.А.      | Черный человек        |
| Лермонтов М.Ю.   | NULL                  |
| Пастернак Б.Л.   | Лирика                |
+------------------+-----------------------+
```
#### Задание
Вывести все жанры, которые не представлены в книгах на складе.
```SQL
SELECT name_genre
FROM genre LEFT JOIN book
  ON genre.genre_id = book.genre_id
WHERE title IS NULL;
```
```
+-------------+
| name_genre  |
+-------------+
| Приключения |
+-------------+
```
## Перекрестное соединение CROSS JOIN
Оператор перекрёстного соединения, или декартова произведения `CROSS JOIN` 
(в запросе вместо ключевых слов можно поставить запятую между таблицами) соединяет две таблицы. 
Порядок таблиц для оператора неважен, поскольку оператор является симметричным. Его структура:
```SQL
SELECT
     ...
FROM
    таблица_1 CROSS JOIN  таблица_2
...
```
или
```SQL
SELECT
     ...
FROM
    таблица_1, таблица_2
...
```
Результат запроса формируется так: каждая строка одной таблицы соединяется с каждой строкой другой таблицы, 
формируя  в результате все возможные сочетания строк двух таблиц.

Например, запрос:
```SQL
SELECT name_author, name_genre
FROM 
    author, genre;
```
каждому автору из таблицы `author` поставит в соответствие все возможные жанры из таблицы `genre`:
```
+------------------+-------------+
| name_author      | name_genre  |
+------------------+-------------+
| Булгаков М.А.    | Роман       |
| Булгаков М.А.    | Поэзия      |
| Булгаков М.А.    | Приключения |
| Достоевский Ф.М. | Роман       |
| Достоевский Ф.М. | Поэзия      |
| Достоевский Ф.М. | Приключения |
| Есенин С.А.      | Роман       |
| Есенин С.А.      | Поэзия      |
| Есенин С.А.      | Приключения |
| Пастернак Б.Л.   | Роман       |
| Пастернак Б.Л.   | Поэзия      |
| Пастернак Б.Л.   | Приключения |
| Лермонтов М.Ю.   | Роман       |
| Лермонтов М.Ю.   | Поэзия      |
| Лермонтов М.Ю.   | Приключения |
+------------------+-------------+
```
#### Задание
Есть список городов, хранящийся в таблице `city`:
```
+---------+-----------------+
| city_id | name_city       |
+---------+-----------------+
| 1       | Москва          |
| 2       | Санкт-Петербург |
| 3       | Владивосток     |
+---------+-----------------+
```
Необходимо в каждом городе провести выставку книг каждого автора в течение 2020 года. Дату проведения выставки выбрать случайным образом. 
Создать запрос, который выведет город, автора и дату проведения выставки. Последний столбец назвать `Дата`. 
Информацию вывести, отсортировав сначала в алфавитном порядке по названиям городов, а потом по убыванию дат проведения выставок.
```SQL
SELECT name_city, name_author,
    DATE_ADD("2020-01-01", INTERVAL FLOOR(RAND() * 365) DAY) AS Дата
FROM city, author
ORDER BY name_city, Дата DESC;
```
```
+-----------------+------------------+------------+
| name_city       | name_author      | Дата       |
+-----------------+------------------+------------+
| Владивосток     | Достоевский Ф.М. | 2020-12-04 |
| Владивосток     | Лермонтов М.Ю.   | 2020-10-21 |
| Владивосток     | Пастернак Б.Л.   | 2020-08-23 |
| Владивосток     | Есенин С.А.      | 2020-08-14 |
| Владивосток     | Булгаков М.А.    | 2020-01-08 |
| Москва          | Лермонтов М.Ю.   | 2020-09-30 |
| Москва          | Достоевский Ф.М. | 2020-07-21 |
| Москва          | Есенин С.А.      | 2020-06-23 |
| Москва          | Булгаков М.А.    | 2020-05-28 |
| Москва          | Пастернак Б.Л.   | 2020-04-08 |
| Санкт-Петербург | Булгаков М.А.    | 2020-11-05 |
| Санкт-Петербург | Лермонтов М.Ю.   | 2020-10-22 |
| Санкт-Петербург | Достоевский Ф.М. | 2020-09-19 |
| Санкт-Петербург | Есенин С.А.      | 2020-08-11 |
| Санкт-Петербург | Пастернак Б.Л.   | 2020-06-28 |
+-----------------+------------------+------------+
```
## Запросы на выборку из нескольких таблиц
Запрос на выборку может выбирать данные из двух и более таблиц базы данных. При этом таблицы должны быть логически связаны между собой. Для каждой пары таблиц, включаемых в запрос, необходимо указать свой оператор соединения. Наиболее распространенным является внутреннее соединение `INNER JOIN`, поэтому в примерах будем использовать его.

Пусть таблицы связаны между собой следующим образом:

![pic1](https://ucarecdn.com/ce01d392-5623-4e6c-aa60-2f58246a2b7f/)
```SQL
SELECT
     ...
FROM
    first 
    INNER JOIN  second ON first.first_id = second.first_id
    INNER JOIN  third  ON second.second_id = third.second_id
...
```
Если же таблицы связаны так:

![pic2](https://ucarecdn.com/5da25bff-06fd-42f7-a32e-3fc65ca67954/)

В этом случае рекомендуется соединение таблиц записывать последовательно, «по кругу»: `first → third → second`. 
`INNER JOIN` симметричен относительно перестановок, поэтому возможны все другие комбинации `first → second → third`, `second → first → third` и т.д.
```SQL
SELECT
    ...
FROM
    first 
    INNER JOIN  third ON first.first_id = third.first_id
    INNER JOIN second ON third.second_id = second.second_id 
...
```
**Пример**

Вывести информацию о тех книгах, их авторах и жанрах, цена которых принадлежит интервалу от 500  до 700 рублей  включительно.
```SQL
SELECT title, name_author, name_genre, price, amount
FROM author 
    INNER JOIN  book ON author.author_id = book.author_id
    INNER JOIN genre ON genre.genre_id = book.genre_id
WHERE price BETWEEN 500 AND 700;
```
```
+-----------------------+----------------+------------+--------+--------+
| title                 | name_author    | name_genre | price  | amount |
+-----------------------+----------------+------------+--------+--------+
| Мастер и Маргарита    | Булгаков М.А.  | Роман      | 670.99 | 3      |
| Белая гвардия         | Булгаков М.А.  | Роман      | 540.50 | 5      |
| Стихотворения и поэмы | Есенин С.А.    | Поэзия     | 650.00 | 15     |
| Черный человек        | Есенин С.А.    | Поэзия     | 570.20 | 6      |
| Лирика                | Пастернак Б.Л. | Поэзия     | 518.99 | 2      |
+-----------------------+----------------+------------+--------+--------+
```
#### Задание
Вывести информацию о книгах (жанр, книга, автор), относящихся к жанру, включающему слово «роман» в отсортированном по названиям книг виде.

![pic3](https://ucarecdn.com/95045d96-412d-4e10-88f2-7ac6b13fada6/)
```SQL
SELECT name_genre, title, name_author
FROM genre
  INNER JOIN book ON genre.genre_id = book.genre_id
  INNER JOIN author ON author.author_id = book.author_id
WHERE name_genre LIKE "роман"
ORDER BY title;
```
```
+------------+--------------------+------------------+
| name_genre | title              | name_author      |
+------------+--------------------+------------------+
| Роман      | Белая гвардия      | Булгаков М.А.    |
| Роман      | Братья Карамазовы  | Достоевский Ф.М. |
| Роман      | Игрок              | Достоевский Ф.М. |
| Роман      | Идиот              | Достоевский Ф.М. |
| Роман      | Мастер и Маргарита | Булгаков М.А.    |
+------------+--------------------+------------------+
```
## Запросы для нескольких таблиц с группировкой
Вывести количество различных книг каждого автора. Информацию отсортировать в алфавитном порядке по фамилиям  авторов.
```SQL
SELECT name_author, count(title) AS Количество
FROM 
    author INNER JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
ORDER BY name_author;
```
```
+------------------+------------+
| name_author      | Количество |
+------------------+------------+
| Булгаков М.А.    | 2          |
| Достоевский Ф.М. | 3          |
| Есенин С.А.      | 2          |
| Пастернак Б.Л.   | 1          |
+------------------+------------+
```
Здесь использовался `INNER JOIN` и мы пропустили Лермонтова, которого нет на складе. Чтобы это учесть, надо использовать `LEFT JOIN`.
```SQL
SELECT name_author, count(title) AS Количество
FROM 
    author LEFT JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
ORDER BY name_author;
```
```
+------------------+------------+
| name_author      | Количество |
+------------------+------------+
| Булгаков М.А.    | 2          |
| Достоевский Ф.М. | 3          |
| Есенин С.А.      | 2          |
| Лермонтов М.Ю.   | 0          |
| Пастернак Б.Л.   | 1          |
+------------------+------------+
```
#### Задание
Посчитать количество экземпляров  книг каждого автора из таблицы `author`.  Вывести тех авторов,  количество книг которых меньше 10, в отсортированном по возрастанию количества виде. Последний столбец назвать `Количество`.
```SQL
SELECT name_author,
       SUM(amount) AS Количество
FROM author LEFT JOIN book 
  ON  author.author_id = book.author_id
GROUP BY name_author
HAVING Количество < 10 OR COUNT(title) = 0
ORDER BY Количество;
```
```
+----------------+------------+
| name_author    | Количество |
+----------------+------------+
| Лермонтов М.Ю. | NULL       |
| Пастернак Б.Л. | 2          |
| Булгаков М.А.  | 8          |
+----------------+------------+
```
## Запросы для нескольких таблиц со вложенными запросами
В запросах, построенных на нескольких таблицах, можно использовать вложенные запросы. Вложенный запрос может быть включен:  после ключевого слова `SELECT`,  после `FROM` и в условие отбора после `WHERE` (`HAVING`).

**Пример**

Вывести авторов, общее количество книг которых на складе максимально.

*Шаг 1.* Найдем суммарное количество книг на складе по каждому автору. Поскольку фамилии автора в этой таблице нет, то группировку будем осуществлять по `author_id`.
```SQL
SELECT author_id, SUM(amount) AS sum_amount 
FROM book 
GROUP BY author_id
```
```
+-----------+------------+
| author_id | sum_amount |
+-----------+------------+
| 1         | 8          |
| 2         | 23         |
| 3         | 21         |
| 4         | 2          |
+-----------+------------+
```
*Шаг 2.* В результирующей таблице предыдущего запроса необходимо найти максимальное значение, то есть 23. Для этого запросу, созданному на шаге 1, необходимо присвоить имя (например, `query_in`) и использовать его в качестве таблицы-источника после `FROM`. Затем уже находить максимум по столбцу `sum_amount`.
```SQL
SELECT MAX(sum_amount) AS max_sum_amount
FROM 
    (
     SELECT author_id, SUM(amount) AS sum_amount 
     FROM book 
     GROUP BY author_id
    ) query_in
```
```
+----------------+
| max_sum_amount |
+----------------+
| 23             |
+----------------+
```
*Шаг 3.* Выведем фамилию автора и общее количество книг для него.
```SQL
+------------------+------------+
| name_author      | Количество |
+------------------+------------+
| Булгаков М.А.    | 8          |
| Достоевский Ф.М. | 23         |
| Есенин С.А.      | 21         |
| Пастернак Б.Л.   | 2          |
+------------------+------------+
```
*Шаг 4.*  Включим запрос с шага 2 в условие отбора запроса с шага 3. И получим всех авторов, общее количество книг которых максимально.
```SQL
SELECT name_author, SUM(amount) as Количество
FROM 
    author INNER JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
HAVING SUM(amount) = 
     (/* вычисляем максимальное из общего количества книг каждого автора */
      SELECT MAX(sum_amount) AS max_sum_amount
      FROM 
          (/* считаем количество книг каждого автора */
            SELECT author_id, SUM(amount) AS sum_amount 
            FROM book GROUP BY author_id
          ) query_in
      );
```
```
+------------------+------------+
| name_author      | Количество |
+------------------+------------+
| Достоевский Ф.М. | 23         |
+------------------+------------+
```
#### Задание
Вывести в алфавитном порядке всех авторов, которые пишут только в одном жанре. Поскольку у нас в таблицах так занесены данные, что у каждого автора книги только в одном жанре,  для этого запроса внесем изменения в таблицу `book`. Пусть у нас  книга Есенина «Черный человек» относится к жанру «Роман», а книга Булгакова «Белая гвардия» к «Приключениям» (эти изменения в таблицы уже внесены).
```
+---------+-----------------------+-----------+----------+--------+--------+
| book_id | title                 | author_id | genre_id | price  | amount |
+---------+-----------------------+-----------+----------+--------+--------+
| 1       | Мастер и Маргарита    | 1         | 1        | 670.99 | 3      |
| 2       | Белая гвардия         | 1         | 3        | 540.50 | 5      |
| 3       | Идиот                 | 2         | 1        | 460.00 | 10     |
| 4       | Братья Карамазовы     | 2         | 1        | 799.01 | 3      |
| 5       | Игрок                 | 2         | 1        | 480.50 | 10     |
| 6       | Стихотворения и поэмы | 3         | 2        | 650.00 | 15     |
| 7       | Черный человек        | 3         | 1        | 570.20 | 6      |
| 8       | Лирика                | 4         | 2        | 518.99 | 2      |
+---------+-----------------------+-----------+----------+--------+--------+
```
Решение:
```SQL
SELECT name_author
FROM author INNER JOIN
     (SELECT author_id
      FROM (SELECT author_id
            FROM book
            GROUP BY author_id, genre_id) AS authors_with_genres
      GROUP BY author_id
      HAVING COUNT(*) = 1) AS needed_ids
  ON needed_ids.author_id = author.author_id
ORDER BY name_author;
```
```
+------------------+
| name_author      |
+------------------+
| Достоевский Ф.М. |
| Пастернак Б.Л.   |
+------------------+
```
Здесь выбираем авторов и все их жанры:
```SQL
SELECT author_id
FROM book
GROUP BY author_id, genre_id
```
Дальше считаем, когда жанр у автора попадается только один:
```SQL
SELECT author_id
FROM (SELECT author_id
            FROM book
            GROUP BY author_id, genre_id) AS authors_with_genres
GROUP BY author_id
HAVING COUNT(*) = 1
```
И этих автором сопоставляем с их именами через `JOIN` с таблицей `author`.

Можно и без `JOIN`:
```SQL
SELECT name_author FROM author 
WHERE author_id IN(SELECT DISTINCT author_id FROM book
                    GROUP BY author_id
                    HAVING COUNT(DISTINCT genre_id) = 1)
```
## Вложенные запросы в операторах соединения
Вложенные запросы могут использоваться в операторах соединения `JOIN`.  При этом им необходимо присваивать имя, которое записывается сразу после закрывающей скобки вложенного запроса. Вложенный запрос может стоять как справа, так и слева от оператора `JOIN`. Допускается использование двух запросов в операторах соединения.
Рекомендуется, если запрос будет использоваться в качестве вложенного (особенно в операциях соединения), вычисляемым полям запроса давать собственное имя.
```SQL
SELECT
    ...
FROM
    таблица ... JOIN  
       (
        SELECT ...
       ) имя_вложенного_запроса
    ON условие
...
```
**Пример**

Вывести авторов, пишущих книги в самом популярном жанре. Указать этот жанр.

Самым популярным считать жанр, общее количество экземпляров книг которого на складе максимально. Таких жанров может быть несколько, если они имеют одинаковое максимальное значение общего количества экземпляров. Только для этого шага изменена таблица `book`.

*Шаг 1.* Найдем общее количество книг по каждому жанру, отсортируем его по убыванию и ограничим вывод одной строкой.
```SQL
SELECT genre_id, SUM(amount) AS sum_amount
FROM book
GROUP BY genre_id
ORDER BY sum_amount DESC
```
```
+----------+------------+
| genre_id | sum_amount |
+----------+------------+
| 1        | 31         |
| 2        | 31         |
| 3        | 7          |
+----------+------------+
```
Дальше будем писать `LIMIT 1`, так это все равно будет максимальное количество книг по жанру. 
Как было видно, несколько жанров имеют максимальное количество книг. 
Поэтому нам необходим запрос, который отберет ВСЕ жанры, суммарное количество книг которых равно `sum_amount`.

*Шаг 2.* Используя запрос с предыдущего шага, найдем `id` самых популярных жанров.
```SQL
SELECT query_in_1.genre_id
FROM 
    (/* выбираем код жанра и количество произведений, относящихся к нему */
      SELECT genre_id, SUM(amount) AS sum_amount
      FROM book
      GROUP BY genre_id 
    )query_in_1
    INNER JOIN
    (/* выбираем запись, в которой указан код жанр с максимальным количеством книг */
      SELECT genre_id, SUM(amount) AS sum_amount
      FROM book
      GROUP BY genre_id
      ORDER BY sum_amount DESC
      LIMIT 1
     ) query_in_2
     ON query_in_1.sum_amount= query_in_2.sum_amount              
```
```
+----------+
| genre_id |
+----------+
| 1        |
| 2        |
+----------+
```
*Шаг 3.* Используя запрос с шага 2, выведем фамилии авторов, которые пишут в самых популярных жанрах, и названия этих жанров. В этом запросе обязательно выполнить группировку по фамилиям авторов и `id` жанров, так как без этого фамилии авторов будут повторяться, поскольку в таблице `book` есть разные книги, написанные автором в одном жанре.
```SQL
SELECT  name_author, name_genre
FROM 
    author 
    INNER JOIN book ON author.author_id = book.author_id
    INNER JOIN genre ON  book.genre_id = genre.genre_id
GROUP BY name_author,name_genre, genre.genre_id
HAVING genre.genre_id IN
         (/* выбираем автора, если он пишет книги в самых популярных жанрах*/
          SELECT query_in_1.genre_id
          FROM 
              ( /* выбираем код жанра и количество произведений, относящихся к нему */
                SELECT genre_id, SUM(amount) AS sum_amount
                FROM book
                GROUP BY genre_id
               )query_in_1
          INNER JOIN 
              ( /* выбираем запись, в которой указан код жанр с максимальным количеством книг */
                SELECT genre_id, SUM(amount) AS sum_amount
                FROM book
                GROUP BY genre_id
                ORDER BY sum_amount DESC
                LIMIT 1
               ) query_in_2
          ON query_in_1.sum_amount= query_in_2.sum_amount
         );  
```
*Важно!* 

1. Обратите внимание, что в группировку включен столбец `genre_id`, который используется в `HAVING`. Это связано с тем, что в `HAVING` можно использовать либо столбцы, перечисленные в `GROUP BY`, либо вычисляемые с помощью групповых функций столбцы. Добавление столбца `genre_id` не влияет на группировку, так как между названием жанра и его `id` - взаимно-однозначное соответствие.
2. Название столбца `genre_id` задается с указанием имени таблицы (`genre.genre_id`), так как этот столбец входит в структуру двух таблиц `book` и `genre`.  Для этого запроса можно было бы указать и `book.genre_id`, так как эти таблицы связаны внутренним соединением `INNER JOIN` и имеют одинаковые значения в полях `genre.genre_id` и `book.genre_id`.
```
+------------------+------------+
| name_author      | name_genre |
+------------------+------------+
| Достоевский Ф.М. | Роман      |
| Булгаков М.А.    | Роман      |
| Пастернак Б.Л.   | Поэзия     |
| Есенин С.А.      | Поэзия     |
+------------------+------------+
```
**Мое решение** должно быть хуже по времени, так как тут 5 вложенных запросов против 3 в учебном решении.
```SQL
SELECT name_author, name_genre
FROM 
  ( -- ответ в числовых id: авторы - популярные жанры
  SELECT author_id, genre_id FROM book
  WHERE genre_id IN 
     ( -- список самых популярных жанров
     SELECT genre_id 
     FROM 
         ( -- отбираем жанр-количество
           SELECT 
             genre_id, 
             SUM(amount) AS sum_am
           FROM book
           GROUP BY genre_id
          ) AS genre_amount
     WHERE 
          genre_amount.sum_am = 
                            ( -- отбираем максимальное количество 
                              SELECT MAX(am) 
                              FROM 
                                  ( -- отбираем жанр-количество
                                    SELECT genre_id, SUM(amount) AS am
                                    FROM book
                                    GROUP BY genre_id
                                  ) AS t_amount
                            ) -- отбрали максимальное количество 
    ) -- конец списка самых популярных жанров
  GROUP BY author_id, genre_id
  ) AS authors -- конец ответа в числовых id: авторы - популярные жанры
  -- присваиваем имена авторов и жанров вместо id
  LEFT JOIN author ON authors.author_id = author.author_id
  LEFT JOIN genre  ON authors.genre_id = genre.genre_id;
```
#### Задание
Вывести информацию о книгах (название книги, фамилию и инициалы автора, название жанра, цену и количество экземпляров книги), написанных в самых популярных жанрах, в отсортированном в алфавитном порядке по названию книг виде. Самым популярным считать жанр, общее количество экземпляров книг которого на складе максимально.
```SQL
SELECT title, name_author, name_genre, price, amount
FROM book
LEFT JOIN author ON author.author_id = book.author_id
LEFT JOIN genre  ON genre.genre_id = book.genre_id
WHERE book.genre_id IN 
    ( -- список саммых популярных жанров
        SELECT g_sa.genre_id
        FROM 
            (-- таблица жанр-количество
                SELECT genre_id, SUM(amount) AS sum_amount
                FROM book
                GROUP BY genre_id
            ) AS g_sa
        INNER JOIN 
            (-- таблица жанр-количество с максимальным количеством
                SELECT genre_id, SUM(amount) AS sum_amount
                FROM book
                GROUP BY genre_id
                ORDER BY sum_amount DESC
                LIMIT 1
            )AS g_max
        ON g_sa.sum_amount = g_max.sum_amount        
    )
ORDER BY title;
```
```
+-----------------------+------------------+------------+--------+--------+
| title                 | name_author      | name_genre | price  | amount |
+-----------------------+------------------+------------+--------+--------+
| Белая гвардия         | Булгаков М.А.    | Роман      | 540.50 | 5      |
| Братья Карамазовы     | Достоевский Ф.М. | Роман      | 799.01 | 3      |
| Игрок                 | Достоевский Ф.М. | Роман      | 480.50 | 10     |
| Идиот                 | Достоевский Ф.М. | Роман      | 460.00 | 10     |
| Лирика                | Пастернак Б.Л.   | Поэзия     | 518.99 | 10     |
| Мастер и Маргарита    | Булгаков М.А.    | Роман      | 670.99 | 3      |
| Стихотворения и поэмы | Есенин С.А.      | Поэзия     | 650.00 | 15     |
| Черный человек        | Есенин С.А.      | Поэзия     | 570.20 | 6      |
+-----------------------+------------------+------------+--------+--------+
```
